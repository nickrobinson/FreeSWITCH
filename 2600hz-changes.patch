From a01a148f0f86bcc392482b791cea30b6f287318f Mon Sep 17 00:00:00 2001
From: karl anderson <karl@2600hz.com>
Date: Fri, 24 May 2013 20:29:38 +0000
Subject: [PATCH] 2600hz Changes - apply against upstream FreeSWITCH commit aecd186ba50050137b91cbb0c6640f1b846c6cbd

---
 build/modules.conf.in                              |   35 +-
 configure.in                                       |    1 +
 freeswitch.spec                                    |   62 +-
 src/include/switch_apr.h                           |    1 +
 src/mod/applications/mod_channel_move/Makefile     |    2 +
 .../mod_channel_move/mod_channel_move.c            |  348 ++++++
 .../mod_channel_move/mod_channel_move.h            |   37 +
 .../mod_channel_move/mod_skel.2008.vcproj          |  287 +++++
 .../mod_channel_move/mod_skel.2010.vcxproj         |  131 +++
 src/mod/applications/mod_dptools/mod_dptools.c     |    6 +-
 .../applications/mod_http_cache/mod_http_cache.c   |    2 +-
 src/mod/endpoints/mod_loopback/mod_loopback.c      |    7 +
 src/mod/endpoints/mod_sofia/mod_sofia.c            |   26 +
 src/mod/endpoints/mod_sofia/mod_sofia.h            |    3 +
 src/mod/endpoints/mod_sofia/sofia.c                |   66 ++-
 src/mod/endpoints/mod_sofia/sofia_reg.c            |   53 +-
 src/mod/event_handlers/mod_kazoo/Makefile.in       |    8 +
 .../mod_kazoo/conf/autoload_configs/kazoo.conf.xml |  155 +++
 .../event_handlers/mod_kazoo/kazoo_event_stream.c  |  534 +++++++++
 .../event_handlers/mod_kazoo/kazoo_fetch_agent.c   |  705 ++++++++++++
 src/mod/event_handlers/mod_kazoo/kazoo_node.c      | 1150 ++++++++++++++++++++
 src/mod/event_handlers/mod_kazoo/kazoo_utils.c     |  512 +++++++++
 src/mod/event_handlers/mod_kazoo/mod_kazoo.c       |  705 ++++++++++++
 src/mod/event_handlers/mod_kazoo/mod_kazoo.h       |  155 +++
 src/switch_apr.c                                   |    5 +
 src/switch_ivr_play_say.c                          |    1 +
 26 files changed, 4892 insertions(+), 105 deletions(-)
 create mode 100644 src/mod/applications/mod_channel_move/Makefile
 create mode 100644 src/mod/applications/mod_channel_move/mod_channel_move.c
 create mode 100644 src/mod/applications/mod_channel_move/mod_channel_move.h
 create mode 100644 src/mod/applications/mod_channel_move/mod_skel.2008.vcproj
 create mode 100644 src/mod/applications/mod_channel_move/mod_skel.2010.vcxproj
 create mode 100644 src/mod/event_handlers/mod_kazoo/Makefile.in
 create mode 100644 src/mod/event_handlers/mod_kazoo/conf/autoload_configs/kazoo.conf.xml
 create mode 100644 src/mod/event_handlers/mod_kazoo/kazoo_event_stream.c
 create mode 100644 src/mod/event_handlers/mod_kazoo/kazoo_fetch_agent.c
 create mode 100644 src/mod/event_handlers/mod_kazoo/kazoo_node.c
 create mode 100644 src/mod/event_handlers/mod_kazoo/kazoo_utils.c
 create mode 100644 src/mod/event_handlers/mod_kazoo/mod_kazoo.c
 create mode 100644 src/mod/event_handlers/mod_kazoo/mod_kazoo.h

diff --git a/build/modules.conf.in b/build/modules.conf.in
index 3907136..d950656 100644
--- a/build/modules.conf.in
+++ b/build/modules.conf.in
@@ -3,25 +3,25 @@
 #applications/mod_blacklist
 #applications/mod_callcenter
 #applications/mod_cidlookup
-applications/mod_cluechoo
+#applications/mod_cluechoo
 applications/mod_commands
 applications/mod_conference
 #applications/mod_curl
-applications/mod_db
+#applications/mod_db
 #applications/mod_directory
 #applications/mod_distributor
 applications/mod_dptools
 #applications/mod_easyroute
-applications/mod_enum
+#applications/mod_enum
 applications/mod_esf
 #applications/mod_esl
 applications/mod_expr
-applications/mod_fifo
+#applications/mod_fifo
 #applications/mod_fsk
 applications/mod_fsv
-applications/mod_hash
-applications/mod_httapi
-#applications/mod_http_cache
+#applications/mod_hash
+#applications/mod_httapi
+applications/mod_http_cache
 #applications/mod_ladspa
 #applications/mod_lcr
 #applications/mod_memcache
@@ -38,11 +38,12 @@ applications/mod_sms
 applications/mod_spandsp
 #applications/mod_spy
 #applications/mod_stress
-applications/mod_valet_parking
+#applications/mod_valet_parking
 #applications/mod_vmd
-applications/mod_voicemail
+#applications/mod_voicemail
 #applications/mod_voicemail_ivr
 #applications/mod_random
+applications/mod_channel_move
 #asr_tts/mod_cepstral
 #asr_tts/mod_flite
 #asr_tts/mod_pocketsphinx
@@ -64,9 +65,9 @@ codecs/mod_vp8
 #codecs/mod_opus
 #codecs/mod_sangoma_codec
 #codecs/mod_silk
-#codecs/mod_siren
+codecs/mod_siren
 codecs/mod_speex
-dialplans/mod_dialplan_asterisk
+#dialplans/mod_dialplan_asterisk
 #dialplans/mod_dialplan_directory
 dialplans/mod_dialplan_xml
 #directories/mod_ldap
@@ -82,11 +83,11 @@ endpoints/mod_loopback
 #endpoints/mod_skinny
 #endpoints/mod_skypopen
 endpoints/mod_sofia
-event_handlers/mod_cdr_csv
+#event_handlers/mod_cdr_csv
 #event_handlers/mod_cdr_mongodb
 #event_handlers/mod_cdr_pg_csv
-event_handlers/mod_cdr_sqlite
-#event_handlers/mod_erlang_event
+#event_handlers/mod_cdr_sqlite
+event_handlers/mod_kazoo
 #event_handlers/mod_event_multicast
 event_handlers/mod_event_socket
 #event_handlers/mod_event_zmq
@@ -96,16 +97,16 @@ formats/mod_local_stream
 formats/mod_native_file
 #formats/mod_portaudio_stream
 #formats/mod_shell_stream
-#formats/mod_shout
+formats/mod_shout
 formats/mod_sndfile
 formats/mod_tone_stream
 #formats/mod_vlc
 #languages/mod_java
-languages/mod_lua
+#languages/mod_lua
 #languages/mod_managed
 #languages/mod_perl
 #languages/mod_python
-languages/mod_spidermonkey
+#languages/mod_spidermonkey
 #languages/mod_yaml
 loggers/mod_console
 loggers/mod_logfile
diff --git a/configure.in b/configure.in
index e2821fb..6d8da47 100644
--- a/configure.in
+++ b/configure.in
@@ -1103,6 +1103,7 @@ AC_CONFIG_FILES([Makefile
 		src/mod/languages/mod_python/Makefile
 		src/mod/languages/mod_spidermonkey/Makefile
 		src/mod/event_handlers/mod_erlang_event/Makefile
+		src/mod/event_handlers/mod_kazoo/Makefile
 		src/include/switch_am_config.h
 		build/getsounds.sh
 		build/getlib.sh
diff --git a/freeswitch.spec b/freeswitch.spec
index 4e77fc5..8ab7b77 100644
--- a/freeswitch.spec
+++ b/freeswitch.spec
@@ -939,12 +939,22 @@ SQLite CDR Logger for FreeSWITCH.
 Summary:	Erlang Event Module for the FreeSWITCH open source telephony platform
 Group:		System/Libraries
 Requires:	 %{name} = %{version}-%{release}
-Requires:	erlang
-BuildRequires:	erlang
+Requires:	esl-erlang
+BuildRequires:	esl-erlang
 
 %description event-erlang-event
 Erlang Event Module for FreeSWITCH.
 
+%package event-kazoo
+Summary:	Alternative Erlang Event Module for the FreeSWITCH open source telephony platform
+Group:		System/Libraries
+Requires:	 %{name} = %{version}-%{release}
+Requires:	esl-erlang
+BuildRequires:	esl-erlang
+
+%description event-kazoo
+Alternative Erlang Event Module for FreeSWITCH.
+
 %package event-multicast
 Summary:	Multicast Event System for the FreeSWITCH open source telephony platform
 Group:		System/Libraries
@@ -1118,22 +1128,6 @@ Requires:        %{name} = %{version}-%{release}
 %description lang-he
 Hebrew language phrases module and directory structure for say module and voicemail
 
-%package lang-es
-Summary:        Provides Spanish language dependend modules and speech config for the FreeSWITCH Open Source telephone platform.
-Group:          System/Libraries
-Requires:        %{name} = %{version}-%{release}
-
-%description lang-es
-Spanish language phrases module and directory structure for say module and voicemail
-
-%package lang-pt
-Summary:        Provides Portugese language dependend modules and speech config for the FreeSWITCH Open Source telephone platform.
-Group:          System/Libraries
-Requires:        %{name} = %{version}-%{release}
-
-%description lang-pt
-Hebrew language phrases module and directory structure for say module and voicemail
-
 ######################################################################################################################
 #				FreeSWITCH Timer Modules
 ######################################################################################################################
@@ -1366,7 +1360,7 @@ ENDPOINTS_MODULES="endpoints/mod_dingaling ../../libs/freetdm/mod_freetdm \
 #
 ######################################################################################################################
 EVENT_HANDLERS_MODULES="event_handlers/mod_cdr_csv event_handlers/mod_cdr_pg_csv event_handlers/mod_cdr_sqlite \
-			event_handlers/mod_cdr_mongodb event_handlers/mod_erlang_event event_handlers/mod_event_multicast \
+			event_handlers/mod_cdr_mongodb event_handlers/mod_kazoo event_handlers/mod_erlang_event event_handlers/mod_event_multicast \
 			event_handlers/mod_event_socket event_handlers/mod_json_cdr \
 			event_handlers/mod_snmp"
 
@@ -1749,7 +1743,6 @@ fi
 %config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/autoload_configs/mongo.conf.xml
 %config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/autoload_configs/nibblebill.conf.xml
 %config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/autoload_configs/opal.conf.xml
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/autoload_configs/oreka.conf.xml
 %config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/autoload_configs/osp.conf.xml
 %config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/autoload_configs/pocketsphinx.conf.xml
 %config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/autoload_configs/portaudio.conf.xml
@@ -2165,6 +2158,10 @@ fi
 %defattr(-, freeswitch, daemon)
 %{MODINSTDIR}/mod_erlang_event.so*
 
+%files event-kazoo
+%defattr(-, freeswitch, daemon)
+%{MODINSTDIR}/mod_kazoo.so*
+
 %files event-multicast
 %defattr(-, freeswitch, daemon)
 %{MODINSTDIR}/mod_event_multicast.so*
@@ -2313,30 +2310,6 @@ fi
 %config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/he/dir/*.xml
 %{MODINSTDIR}/mod_say_he.so*
 
-%files lang-es
-%defattr(-, freeswitch, daemon)
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/es
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/es/demo
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/es/vm
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/es/dir
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/es/*.xml
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/es/demo/*.xml
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/es/vm/*.xml
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/es/dir/*.xml
-%{MODINSTDIR}/mod_say_en.so*
-
-%files lang-pt
-%defattr(-, freeswitch, daemon)
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/pt
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/pt/demo
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/pt/vm
-%dir %attr(0750, freeswitch, daemon) %{sysconfdir}/lang/pt/dir
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/pt/*.xml
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/pt/demo/*.xml
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/pt/vm/*.xml
-%config(noreplace) %attr(0640, freeswitch, daemon) %{sysconfdir}/lang/pt/dir/*.xml
-%{MODINSTDIR}/mod_say_en.so*
-
 ######################################################################################################################
 #
 #					Timer Modules
@@ -2530,4 +2503,3 @@ fi
 - Added devel package
 * Thu Mar 15 2007 - peter+rpmspam@suntel.com.tr
 - Initial RPM release
-
diff --git a/src/include/switch_apr.h b/src/include/switch_apr.h
index ace5f18..7d4b9c7 100644
--- a/src/include/switch_apr.h
+++ b/src/include/switch_apr.h
@@ -1449,6 +1449,7 @@ SWITCH_DECLARE(switch_status_t) switch_socket_create_pollset(switch_pollfd_t **
 SWITCH_DECLARE(switch_status_t) switch_socket_create_pollfd(switch_pollfd_t **pollfd, switch_socket_t *sock, int16_t flags, void *client_data, switch_memory_pool_t *pool);
 SWITCH_DECLARE(switch_status_t) switch_match_glob(const char *pattern, switch_array_header_t ** result, switch_memory_pool_t *p);
 SWITCH_DECLARE(switch_status_t) switch_os_sock_get(switch_os_socket_t *thesock, switch_socket_t *sock);
+SWITCH_DECLARE(switch_status_t) switch_os_sock_put(switch_socket_t **sock, switch_os_socket_t *thesock, switch_memory_pool_t *cont);
 SWITCH_DECLARE(switch_status_t) switch_socket_addr_get(switch_sockaddr_t ** sa, switch_bool_t remote, switch_socket_t *sock);
 
 /**
diff --git a/src/mod/applications/mod_channel_move/Makefile b/src/mod/applications/mod_channel_move/Makefile
new file mode 100644
index 0000000..2c35e6e
--- /dev/null
+++ b/src/mod/applications/mod_channel_move/Makefile
@@ -0,0 +1,2 @@
+BASE=../../../..
+include $(BASE)/build/modmake.rules
diff --git a/src/mod/applications/mod_channel_move/mod_channel_move.c b/src/mod/applications/mod_channel_move/mod_channel_move.c
new file mode 100644
index 0000000..52cc4cc
--- /dev/null
+++ b/src/mod/applications/mod_channel_move/mod_channel_move.c
@@ -0,0 +1,348 @@
+/* 
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2012, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * 
+ * Darren Schreiber <d@d-man.org>
+ *
+ *
+ * mod_channel_move.c -- Utilize eventing and channel recovery routines to allow for channel move abilities
+ *
+ */
+#include <switch.h>
+#include "mod_channel_move.h"
+
+/* Prototypes */
+SWITCH_MODULE_SHUTDOWN_FUNCTION(mod_channel_move_shutdown);
+SWITCH_MODULE_RUNTIME_FUNCTION(mod_channel_move_runtime);
+SWITCH_MODULE_LOAD_FUNCTION(mod_channel_move_load);
+
+/* SWITCH_MODULE_DEFINITION(name, load, shutdown, runtime) 
+ */
+SWITCH_MODULE_DEFINITION(mod_channel_move, mod_channel_move_load, mod_channel_move_shutdown, NULL);
+
+
+static int silent_destroy(char *technology, char *channel_id)
+{
+	switch_core_session_t *session = switch_core_session_locate(channel_id);
+	switch_xml_t cdr = NULL;
+	char *xml_cdr_text = NULL;
+	switch_channel_t *channel = NULL;
+
+	if (!session) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Move Channel: The provided channel_id is invalid.\n");
+		return SWITCH_FALSE;
+	}
+
+	/* Fire an event with all call XML data, then mark the channel as moving and kill it.
+	   NOTE: The responsible endpoint must check for the "moving" flag and kill the channel silently. */
+	channel = switch_core_session_get_channel(session);
+	if (!channel) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Move Channel: This session has no channel?\n");
+		switch_core_session_rwunlock(session);
+		return SWITCH_FALSE;
+	}
+
+	if (!switch_channel_test_flag(channel, CF_ANSWERED) || switch_channel_get_state(channel) < CS_SOFT_EXECUTE) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: This channel is not in an answered state. You can only move answered channels.\n");
+		switch_core_session_rwunlock(session);
+		return SWITCH_FALSE;
+	}
+
+	if (switch_channel_test_flag(channel, CF_RECOVERING) || !switch_channel_test_flag(channel, CF_TRACKABLE)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: This channel is not tracked. Please make sure your endpoint has call tracking enabled.\n");
+		switch_core_session_rwunlock(session);
+		return SWITCH_FALSE;
+	}
+
+	switch_channel_set_variable(channel, "channel_is_moving", "true");
+	switch_channel_set_variable(channel, "reset_local_network_on_recovery", "true");
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Generating XML metadata...\n");
+
+	if (switch_ivr_generate_xml_cdr(session, &cdr) == SWITCH_STATUS_SUCCESS) {
+		xml_cdr_text = switch_xml_toxml_nolock(cdr, SWITCH_FALSE);
+		switch_xml_free(cdr);
+	}
+
+	if (xml_cdr_text) {
+		switch_event_t *event = NULL;
+
+		/* Tell the world about the channel, hoping that someone will pick it up */
+		if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_MOVE_RELEASED) == SWITCH_STATUS_SUCCESS) {
+//				 switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "profile_name", profile->name);
+//				 switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "old_node_hostname", mod_sofia_globals.hostname);
+			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "old_node_channel_uuid", switch_core_session_get_uuid(session));
+			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "metadata", xml_cdr_text);
+			switch_event_fire(&event);
+		}
+
+		free(xml_cdr_text);
+	}
+
+	/* So long and thanks for all the phish */
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Quietly killing channel...\n");
+	switch_channel_hangup(channel, SWITCH_CAUSE_REDIRECTION_TO_NEW_DESTINATION);
+	switch_core_session_rwunlock(session);
+
+	return SWITCH_TRUE;
+
+}
+
+
+static char *recover_callback(char *technology, char *xml_str)
+{
+	switch_xml_t xml;
+	switch_endpoint_interface_t *ep;
+	switch_core_session_t *session;
+	char *r = NULL;
+
+	if (!(xml = switch_xml_parse_str_dynamic(xml_str, SWITCH_TRUE))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "XML ERROR\n");
+		return SWITCH_FALSE;
+	}
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "%s\n", xml_str);
+
+	if (!(ep = switch_loadable_module_get_endpoint_interface(technology))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Move Channel: EP ERROR\n");
+		return SWITCH_FALSE;
+	}
+
+	if (!(session = switch_core_session_request_xml(ep, NULL, xml))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Move Channel: Invalid XML CDR data, call not recovered\n");
+		goto end;
+	}
+
+	if (ep->recover_callback) {
+		switch_caller_extension_t *extension = NULL;
+
+		if (ep->recover_callback(session) > 0) {
+			switch_channel_t *channel = switch_core_session_get_channel(session);
+
+			if (switch_channel_get_partner_uuid(channel)) {
+				switch_channel_set_flag(channel, CF_RECOVERING_BRIDGE);
+			} else {
+				switch_xml_t callflow, param, x_extension;
+				if ((extension = switch_caller_extension_new(session, "recovery", "recovery")) == 0) {
+					abort();
+				}
+
+				if ((callflow = switch_xml_child(xml, "callflow")) && (x_extension = switch_xml_child(callflow, "extension"))) {
+					for (param = switch_xml_child(x_extension, "application"); param; param = param->next) {
+						const char *var = switch_xml_attr_soft(param, "app_name");
+						const char *val = switch_xml_attr_soft(param, "app_data");
+						/* skip announcement type apps */
+						if (strcasecmp(var, "speak") && strcasecmp(var, "playback") && strcasecmp(var, "gentones") && strcasecmp(var, "say")) {
+							switch_caller_extension_add_application(session, extension, var, val);
+						}
+					}
+				}
+
+				switch_channel_set_caller_extension(channel, extension);
+			}
+
+			switch_channel_set_state(channel, CS_INIT);
+			switch_channel_set_variable(channel, "channel_is_moving", NULL);
+			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_NOTICE, 
+							"Move Channel: Resurrecting fallen channel %s\n", switch_channel_get_name(channel));
+
+			switch_core_session_thread_launch(session);
+
+			r = switch_channel_get_uuid(channel);
+		}
+
+	} else {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Move Channel: Endpoint %s has no recovery function\n", technology);
+	}
+
+
+ end:
+
+	UNPROTECT_INTERFACE(ep);
+
+	switch_xml_free(xml);
+
+	return r;
+}
+
+
+
+
+/* channel_move_event_handler  handles events requesting channels be moved (destroy and recover)
+ *    technology - We always need the technology. This is the endpoint technology that is being recovered (like mod_sofia)
+ *    channel_id - Required if we are destroying (starting a move) a channel in preparation for recreation
+ *    metadata   - Required if we are restoring (completing) a channel move
+ *
+ *  As a rule, if channel_id is present we are starting a move. If metadata is present, we are finishing a move.
+ */
+SWITCH_DECLARE(void) channel_move_event_handler(switch_event_t *event)
+{
+	char *channel_id = switch_event_get_header(event, "channel_id");
+	char *metadata = switch_event_get_header(event, "metadata");
+	char *technology = switch_event_get_header(event, "technology");
+	switch_event_t *completion_event = NULL;
+
+	if (!zstr(technology) && !zstr(metadata)) {
+		 switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Attempting to recreate previously destroyed channel\n");
+		 if ((channel_id = recover_callback(technology, metadata))) {
+
+			/* Tell the world that the channel has moved! */
+			if (switch_event_create_subclass(&completion_event, SWITCH_EVENT_CUSTOM, MY_EVENT_MOVE_COMPLETE) == SWITCH_STATUS_SUCCESS) {
+//				switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "profile_name", h->profile->name);
+//				switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "old_node_hostname", mod_sofia_globals.hostname);
+				switch_event_add_header_string(completion_event, SWITCH_STACK_BOTTOM, "old_node_channel_uuid", channel_id);
+				switch_event_fire(&completion_event);
+			}
+
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Channel is restored on new server as %s!\n", channel_id);
+		} else {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Move Channel: Channel restore failed...\n");
+		}
+
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Done restoring channel.\n");
+
+	} else if (!zstr(technology) && !zstr(channel_id)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Attempting silent destruction of channel\n");
+
+		if (silent_destroy(technology, channel_id) == SWITCH_TRUE) {
+			/* Tell the world about the channel, hoping that the call shall resume */
+			if (switch_event_create_subclass(&completion_event, SWITCH_EVENT_CUSTOM, MY_EVENT_MOVE_COMPLETE) == SWITCH_STATUS_SUCCESS) {
+				switch_event_add_header_string(completion_event, SWITCH_STACK_BOTTOM, "old_node_channel_uuid", channel_id);
+				switch_event_fire(&completion_event);
+			}
+
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Channel is released! Complete the move...\n");
+		} else {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Move Channel: Channel release failed...\n");
+		}
+
+	} else {
+		 switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Move Channel: Move requested but technology and either metadata or channel_id is required\n");
+	}
+}
+
+
+
+
+
+
+/*
+	switch_channel_set_variable(channel, "channel_is_moving", "false");
+
+
+/ *      switch_event_t *event = NULL;
+
+	// Tell the world about the channel, hoping that someone will pick it up
+	if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_RECOVERY_SEND) == SWITCH_STATUS_SUCCESS) {
+		switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "profile_name", profile->name);
+		switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "new_node_runtime_uuid", switch_core_get_uuid());
+		switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "new_node_hostname", mod_sofia_globals.hostname);
+		switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "new_node_channel_uuid", switch_core_session_get_uuid(session));
+		switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "metadata", xml_cdr_text);
+		switch_event_fire(&event);
+	}* /
+
+*/
+
+
+
+/*
+/ * Received a request to move a channel (either to or from)
+   If to this box, will require metadata and will send an event on successful restoration
+   If from this box, will require a channel ID and will send an event containing metadata on successful destroy * /
+void sofia_glue_move_request_event_handler(switch_event_t *event)
+{
+	char *buf = NULL;
+	char *profile_name = NULL;
+
+	switch_assert(event);
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Request to move a channel, deciding if this is new node or old node...\n");
+	if ((buf = switch_event_get_header(event, "metadata")) && (profile_name = switch_event_get_header(event, "profile_name"))) {
+		sofia_profile_t *profile;
+
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Got profile name %s and metadata:\n%s\n", profile_name, buf);
+
+		if ((profile = sofia_glue_find_profile(profile_name))) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Found profile, attempting recovery of channel\n");
+			//sofia_glue_move_restore_channel(profile, buf);
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Channel restored!\n");
+			sofia_glue_release_profile(profile);
+		}
+	} else if ((buf = switch_event_get_header(event, "channel_id")) && (profile_name = switch_event_get_header(event, "profile_name"))) {
+		sofia_profile_t *profile;
+		switch_core_session_t *session;
+
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Got request to move/kill profile name %s and channel %s\n", profile_name, buf);
+
+		if ((profile = sofia_glue_find_profile(profile_name))) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Found profile, attempting to move channel\n");
+			if ((session = switch_core_session_locate(buf))) {
+				sofia_glue_move_release_channel(profile, session);
+				switch_core_session_rwunlock(session);
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Done moving.\n");
+			} else {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Couldn't find the requested channel.\n");
+		}
+			sofia_glue_release_profile(profile);
+		}
+	}
+
+	return;
+}
+*/
+
+
+
+
+
+
+SWITCH_MODULE_LOAD_FUNCTION(mod_channel_move_load)
+{
+	*module_interface = switch_loadable_module_create_module_interface(pool, modname);
+
+        if (switch_event_bind(modname, SWITCH_EVENT_CUSTOM, MY_EVENT_MOVE_REQUEST, channel_move_event_handler, NULL) != SWITCH_STATUS_SUCCESS) {
+                switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Couldn't bind!\n");
+                return SWITCH_STATUS_TERM;
+        }
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "Ready to move channels around the globe!\n");
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+SWITCH_MODULE_SHUTDOWN_FUNCTION(mod_channel_move_shutdown)
+{
+	return SWITCH_STATUS_SUCCESS;
+}
+
+/* For Emacs:
+ * Local Variables:
+ * mode:c
+ * indent-tabs-mode:t
+ * tab-width:4
+ * c-basic-offset:4
+ * End:
+ * For VIM:
+ * vim:set softtabstop=4 shiftwidth=4 tabstop=4
+ */
diff --git a/src/mod/applications/mod_channel_move/mod_channel_move.h b/src/mod/applications/mod_channel_move/mod_channel_move.h
new file mode 100644
index 0000000..7d4525b
--- /dev/null
+++ b/src/mod/applications/mod_channel_move/mod_channel_move.h
@@ -0,0 +1,37 @@
+/* 
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2012, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * 
+ * Darren Schreiber <d@d-man.org>
+ *
+ *
+ * mod_channel_move.h -- Channel Move Facility
+ *
+ */
+
+#define MY_EVENT_MOVE_REQUEST "channel_move::move_request"
+#define MY_EVENT_MOVE_RELEASED "channel_move::move_released"
+#define MY_EVENT_MOVE_COMPLETE "channel_move::move_complete"
+
+
diff --git a/src/mod/applications/mod_channel_move/mod_skel.2008.vcproj b/src/mod/applications/mod_channel_move/mod_skel.2008.vcproj
new file mode 100644
index 0000000..4beaee9
--- /dev/null
+++ b/src/mod/applications/mod_channel_move/mod_skel.2008.vcproj
@@ -0,0 +1,287 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="mod_skel"
+	ProjectGUID="{11C9BC3D-45E9-46E3-BE84-B8CEE4685E39}"
+	RootNamespace="mod_skel"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="131072"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			ConfigurationType="2"
+			InheritedPropertySheets="..\..\..\..\w32\module_debug.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				UsePrecompiledHeader="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="..\..\..\..\w32\module_debug.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				UsePrecompiledHeader="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(SolutionDir)$(PlatformName)\$(ConfigurationName)/mod/$(ProjectName).dll"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			ConfigurationType="2"
+			InheritedPropertySheets="..\..\..\..\w32\module_release.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				UsePrecompiledHeader="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(PlatformName)\$(ConfigurationName)"
+			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			InheritedPropertySheets="..\..\..\..\w32\module_release.vsprops"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				UsePrecompiledHeader="0"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(SolutionDir)$(PlatformName)\$(ConfigurationName)/mod/$(ProjectName).dll"
+				RandomizedBaseAddress="1"
+				DataExecutionPrevention="0"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\mod_skel.c"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/src/mod/applications/mod_channel_move/mod_skel.2010.vcxproj b/src/mod/applications/mod_channel_move/mod_skel.2010.vcxproj
new file mode 100644
index 0000000..6c9d676
--- /dev/null
+++ b/src/mod/applications/mod_channel_move/mod_skel.2010.vcxproj
@@ -0,0 +1,131 @@
+ï»¿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectName>mod_skel</ProjectName>
+    <ProjectGuid>{11C9BC3D-45E9-46E3-BE84-B8CEE4685E39}</ProjectGuid>
+    <RootNamespace>mod_skel</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\..\..\..\w32\module_release.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\..\..\..\w32\module_debug.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\..\..\..\w32\module_release.props" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+    <Import Project="..\..\..\..\w32\module_debug.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+    </ClCompile>
+    <Link>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+    </ClCompile>
+    <Link>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+    </ClCompile>
+    <Link>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+    </ClCompile>
+    <Link>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <DataExecutionPrevention>
+      </DataExecutionPrevention>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="mod_skel.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\..\..\w32\Library\FreeSwitchCore.2010.vcxproj">
+      <Project>{202d7a4e-760d-4d0e-afa1-d7459ced30ff}</Project>
+      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
+    </ProjectReference>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src/mod/applications/mod_dptools/mod_dptools.c b/src/mod/applications/mod_dptools/mod_dptools.c
index 52c9463..0629c8b 100755
--- a/src/mod/applications/mod_dptools/mod_dptools.c
+++ b/src/mod/applications/mod_dptools/mod_dptools.c
@@ -2631,12 +2631,16 @@ SWITCH_STANDARD_APP(playback_function)
 
 SWITCH_STANDARD_APP(endless_playback_function)
 {
+	switch_input_args_t args = { 0 };
 	switch_channel_t *channel = switch_core_session_get_channel(session);
 	switch_status_t status = SWITCH_STATUS_SUCCESS;
 	const char *file = data;
 
+	args.input_callback = on_dtmf;
+
 	while (switch_channel_ready(channel)) {
-		status = switch_ivr_play_file(session, NULL, file, NULL);
+		switch_channel_set_variable(channel, SWITCH_PLAYBACK_TERMINATORS_VARIABLE, "none");
+		status = switch_ivr_play_file(session, NULL, file, &args);
 
 		if (status != SWITCH_STATUS_SUCCESS && status != SWITCH_STATUS_BREAK) {
 			break;
diff --git a/src/mod/applications/mod_http_cache/mod_http_cache.c b/src/mod/applications/mod_http_cache/mod_http_cache.c
index 897a1b9..5656aeb 100644
--- a/src/mod/applications/mod_http_cache/mod_http_cache.c
+++ b/src/mod/applications/mod_http_cache/mod_http_cache.c
@@ -269,7 +269,7 @@ static switch_status_t http_put(url_cache_t *cache, switch_core_session_t *sessi
 	switch_curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &httpRes);
 	switch_curl_easy_cleanup(curl_handle);
 
-	if (httpRes == 200 || httpRes == 201 || httpRes == 204) {
+	if (httpRes == 200 || httpRes == 201 || httpRes == 202 || httpRes == 204) {
 		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, "%s saved to %s\n", filename, url);
 	} else {
 		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_ERROR, "Received HTTP error %ld trying to save %s to %s\n", httpRes, filename, url);
diff --git a/src/mod/endpoints/mod_loopback/mod_loopback.c b/src/mod/endpoints/mod_loopback/mod_loopback.c
index 6d8b491..bba0016 100644
--- a/src/mod/endpoints/mod_loopback/mod_loopback.c
+++ b/src/mod/endpoints/mod_loopback/mod_loopback.c
@@ -455,6 +455,7 @@ static switch_status_t channel_on_execute(switch_core_session_t *session)
 		switch_core_session_t *other_session = NULL;
 		switch_caller_profile_t *cp, *clone;
 		const char *other_uuid = NULL;
+		switch_event_t *event = NULL;
 
 		switch_set_flag(tech_pvt, TFLAG_BOWOUT);
 
@@ -467,6 +468,12 @@ static switch_status_t channel_on_execute(switch_core_session_t *session)
 			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(tech_pvt->session), SWITCH_LOG_INFO, "BOWOUT Replacing loopback channel with real channel: %s\n",
 							  switch_channel_get_name(other_channel));
 
+            if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, "loopback::bowout") == SWITCH_STATUS_SUCCESS) {
+				switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "Resigning-UUID", switch_channel_get_uuid(channel));
+                switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "Acquired-UUID", switch_channel_get_uuid(other_channel));
+                switch_event_fire(&event);
+            }
+
 			if ((cp = switch_channel_get_caller_profile(channel))) {
 				clone = switch_caller_profile_clone(other_session, cp);
 				clone->originator_caller_profile = NULL;
diff --git a/src/mod/endpoints/mod_sofia/mod_sofia.c b/src/mod/endpoints/mod_sofia/mod_sofia.c
index 4a0d72f..cce6ed8 100644
--- a/src/mod/endpoints/mod_sofia/mod_sofia.c
+++ b/src/mod/endpoints/mod_sofia/mod_sofia.c
@@ -520,6 +520,10 @@ switch_status_t sofia_on_hangup(switch_core_session_t *session)
 		switch_core_session_rwunlock(a_session);
 	}
 
+       if (switch_true(switch_channel_get_variable(channel, "channel_is_moving"))) {
+               goto done;
+       }
+
 	if (sofia_test_pflag(tech_pvt->profile, PFLAG_DESTROY)) {
 		sofia_set_flag(tech_pvt, TFLAG_BYE);
 	} else if (tech_pvt->nh && !sofia_test_flag(tech_pvt, TFLAG_BYE)) {
@@ -676,6 +680,8 @@ switch_status_t sofia_on_hangup(switch_core_session_t *session)
 
 	sofia_glue_set_rtp_stats(tech_pvt);
 
+done:
+
 	switch_mutex_unlock(tech_pvt->sofia_mutex);
 
 	return SWITCH_STATUS_SUCCESS;
@@ -3424,6 +3430,26 @@ static void xml_gateway_status(sofia_gateway_t *gp, switch_stream_handle_t *stre
 	stream->write_function(stream, "    <failed-calls-in>%u</failed-calls-in>\n", gp->ib_failed_calls);
 	stream->write_function(stream, "    <failed-calls-out>%u</failed-calls-out>\n", gp->ob_failed_calls);
 
+	if (gp->ib_vars) {
+	  switch_event_header_t *hp;
+
+      stream->write_function(stream, "      <inbound-variables>\n");
+	  for (hp = gp->ib_vars->headers; hp; hp = hp->next) {
+		stream->write_function(stream, "        <variable name=\"%s\" value=\"%s\" />\n", hp->name, hp->value);
+	  }
+      stream->write_function(stream, "      </inbound-variables>\n");
+	}
+
+	if (gp->ob_vars) {
+	  switch_event_header_t *hp;
+
+      stream->write_function(stream, "      <outbound-variables>\n");
+	  for (hp = gp->ob_vars->headers; hp; hp = hp->next) {
+		stream->write_function(stream, "        <variable name=\"%s\" value=\"%s\" />\n", hp->name, hp->value);
+	  }
+      stream->write_function(stream, "      </outbound-variables>\n");
+	}
+
 	if (gp->state == REG_STATE_FAILED || gp->state == REG_STATE_TRYING) {
 		time_t now = switch_epoch_time_now(NULL);
 		if (gp->retry > now) {
diff --git a/src/mod/endpoints/mod_sofia/mod_sofia.h b/src/mod/endpoints/mod_sofia/mod_sofia.h
index db98d8a..62fceac 100644
--- a/src/mod/endpoints/mod_sofia/mod_sofia.h
+++ b/src/mod/endpoints/mod_sofia/mod_sofia.h
@@ -93,6 +93,9 @@ typedef struct private_object private_object_t;
 #define MY_EVENT_RECOVERY_SEND "sofia::recovery_send"
 #define MY_EVENT_RECOVERY_RECOVERED "sofia::recovery_recovered"
 #define MY_EVENT_ERROR "sofia::error"
+#define MY_EVENT_TRANSFEROR "sofia::transferor"
+#define MY_EVENT_TRANSFEREE "sofia::transferee"
+#define MY_EVENT_REPLACED "sofia::replaced"
 
 #define MULTICAST_EVENT "multicast::event"
 #define SOFIA_REPLACES_HEADER "_sofia_replaces_"
diff --git a/src/mod/endpoints/mod_sofia/sofia.c b/src/mod/endpoints/mod_sofia/sofia.c
index ccdc7f5..265669d 100644
--- a/src/mod/endpoints/mod_sofia/sofia.c
+++ b/src/mod/endpoints/mod_sofia/sofia.c
@@ -5744,7 +5744,7 @@ static void sofia_handle_sip_i_state(switch_core_session_t *session, int status,
 
 	if (channel && (status == 180 || status == 183) && switch_channel_direction(channel) == SWITCH_CALL_DIRECTION_OUTBOUND) {
 		const char *val;
-		if ((val = switch_channel_get_variable(channel, "sip_auto_answer")) && switch_true(val)) {
+		if ((val = switch_channel_get_variable(channel, "sip_auto_answer_notify")) && switch_true(val)) {
 			nua_notify(nh, NUTAG_NEWSUB(1), NUTAG_WITH_THIS_MSG(de->data->e_msg), 
 					   NUTAG_SUBSTATE(nua_substate_terminated),SIPTAG_SUBSCRIPTION_STATE_STR("terminated;reason=noresource"), SIPTAG_EVENT_STR("talk"), TAG_END());
 		}
@@ -6684,6 +6684,7 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 	char *full_ref_to = NULL;
 	nightmare_xfer_helper_t *nightmare_xfer_helper;
 	switch_memory_pool_t *npool;
+    switch_event_t *event = NULL;
 
 	if (!(profile->mflags & MFLAG_REFER)) {
 		nua_respond(nh, SIP_403_FORBIDDEN, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
@@ -6876,6 +6877,22 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 									moh = NULL;
 								}
 
+								if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_REPLACED) == SWITCH_STATUS_SUCCESS) {
+								    switch_channel_event_set_data(channel_b, event);
+									switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "att_xfer_replaced_by", br_a);
+									switch_event_fire(&event);
+								}
+				
+								if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEROR) == SWITCH_STATUS_SUCCESS) {
+									switch_channel_event_set_data(channel_a, event);
+									switch_event_fire(&event);
+								}
+
+								if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEREE) == SWITCH_STATUS_SUCCESS) {
+								    switch_channel_event_set_data(a_channel, event);
+									switch_event_fire(&event);
+								}
+
 								if (moh) {
 									char *xdest;
 									xdest = switch_core_session_sprintf(a_session, "endless_playback:%s,park", moh);
@@ -6912,6 +6929,7 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 
 						} else if (br_a && br_b) {
 							switch_core_session_t *tmp = NULL;
+                            switch_event_t *event = NULL;
 
 							switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_NOTICE, "Attended Transfer [%s][%s]\n",
 											  switch_str_nil(br_a), switch_str_nil(br_b));
@@ -6954,8 +6972,32 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 							
 							mark_transfer_record(session, br_a, br_b);
 							
+							if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_REPLACED) == SWITCH_STATUS_SUCCESS) {
+							    switch_channel_event_set_data(channel_b, event);
+								switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "att_xfer_replaced_by", br_a);
+								switch_event_fire(&event);
+							}
+								
+							if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEROR) == SWITCH_STATUS_SUCCESS) {
+								switch_channel_event_set_data(channel_a, event);
+								switch_event_fire(&event);
+							}
+
+							if ((tmp = switch_core_session_locate(br_a))) {
+								switch_channel_t *tchannel = switch_core_session_get_channel(tmp);
+
+								if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEREE) == SWITCH_STATUS_SUCCESS) {
+								    switch_channel_event_set_data(tchannel, event);
+									switch_event_fire(&event);
+								}
+
+								switch_core_session_rwunlock(tmp);
+							}
+
 							switch_ivr_uuid_bridge(br_a, br_b);
+
 							switch_channel_set_variable(channel_b, SWITCH_ENDPOINT_DISPOSITION_VARIABLE, "ATTENDED_TRANSFER");
+
 							nua_notify(tech_pvt->nh, NUTAG_NEWSUB(1), SIPTAG_CONTENT_TYPE_STR("message/sipfrag;version=2.0"),
 									   NUTAG_SUBSTATE(nua_substate_terminated),SIPTAG_SUBSCRIPTION_STATE_STR("terminated;reason=noresource"), SIPTAG_PAYLOAD_STR("SIP/2.0 200 OK\r\n"), SIPTAG_EVENT_STR(etmp),
 									   TAG_END());
@@ -6976,6 +7018,7 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 							} else {
 								switch_core_session_t *t_session, *hup_session;
 								switch_channel_t *hup_channel;
+                                switch_event_t *event = NULL;
 								const char *ext;
 
 								if (br_a && !br_b) {
@@ -7012,6 +7055,16 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 										switch_core_media_bug_transfer_recordings(hup_session, t_session);
 									}
 
+									if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEROR) == SWITCH_STATUS_SUCCESS) {
+										switch_channel_event_set_data(channel_a, event);
+										switch_event_fire(&event);
+									}
+
+									if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEREE) == SWITCH_STATUS_SUCCESS) {
+									    switch_channel_event_set_data(t_channel, event);
+										switch_event_fire(&event);
+									}
+
 									if (idest) {
 										switch_ivr_session_transfer(t_session, idest, "inline", NULL);
 									} else {
@@ -7167,6 +7220,7 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 		if (!zstr(br) && (b_session = switch_core_session_locate(br))) {
 			const char *var;
 			switch_channel_t *b_channel = switch_core_session_get_channel(b_session);
+            switch_event_t *event = NULL;
 
 			switch_channel_set_variable(channel, "transfer_fallback_extension", from->a_user);
 			if (!zstr(full_ref_by)) {
@@ -7200,6 +7254,16 @@ void sofia_handle_sip_i_refer(nua_t *nua, sofia_profile_t *profile, nua_handle_t
 						   SIPTAG_PAYLOAD_STR("SIP/2.0 200 OK\r\n"), SIPTAG_EVENT_STR(etmp), TAG_END());
 			}
 			
+			if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEROR) == SWITCH_STATUS_SUCCESS) {
+				switch_channel_event_set_data(channel_a, event);
+				switch_event_fire(&event);
+			}
+
+			if (switch_event_create_subclass(&event, SWITCH_EVENT_CUSTOM, MY_EVENT_TRANSFEREE) == SWITCH_STATUS_SUCCESS) {
+				switch_channel_event_set_data(b_channel, event);
+				switch_event_fire(&event);
+			}
+			
 			switch_ivr_session_transfer(b_session, exten, NULL, NULL);
 			switch_core_session_rwunlock(b_session);
 		} else {
diff --git a/src/mod/endpoints/mod_sofia/sofia_reg.c b/src/mod/endpoints/mod_sofia/sofia_reg.c
index e94fed4..22a22b4 100644
--- a/src/mod/endpoints/mod_sofia/sofia_reg.c
+++ b/src/mod/endpoints/mod_sofia/sofia_reg.c
@@ -567,6 +567,9 @@ int sofia_reg_nat_callback(void *pArg, int argc, char **argv, char **columnNames
 	char to[512] = "", call_id[512] = "";
 	sofia_destination_t *dst = NULL;
 	switch_uuid_t uuid;
+    char *route_uri = NULL;
+
+	switch_snprintf(to, sizeof(to), "sip:%s@%s", argv[1], argv[2]);
 
 	switch_snprintf(to, sizeof(to), "sip:%s@%s", argv[1], argv[2]);
 
@@ -579,15 +582,17 @@ int sofia_reg_nat_callback(void *pArg, int argc, char **argv, char **columnNames
 	dst = sofia_glue_get_destination(argv[3]);
 	switch_assert(dst);
 	
+	if (dst->route_uri) {
+		route_uri = sofia_glue_strip_uri(dst->route_uri);
+	}
+
 	nh = nua_handle(profile->nua, NULL, SIPTAG_FROM_STR(profile->url), SIPTAG_TO_STR(to), NUTAG_URL(dst->contact), SIPTAG_CONTACT_STR(profile->url),
 					SIPTAG_CALL_ID_STR(call_id), TAG_END());
 	nua_handle_bind(nh, &mod_sofia_globals.destroy_private);
-	nua_options(nh, 
-				NTATAG_SIP_T2(5000),
-				NTATAG_SIP_T4(10000),
-				TAG_IF(dst->route_uri, NUTAG_PROXY(dst->route_uri)), TAG_IF(dst->route, SIPTAG_ROUTE_STR(dst->route)), TAG_END());
+	nua_options(nh, NTATAG_SIP_T2(5000), NTATAG_SIP_T4(10000), TAG_IF(route_uri, NUTAG_PROXY(route_uri)), TAG_IF(dst->route, SIPTAG_ROUTE_STR(dst->route)), TAG_END());
 
 	sofia_glue_free_destination(dst);
+    switch_safe_free(route_uri);
 
 	return 0;
 }
@@ -1092,7 +1097,6 @@ uint8_t sofia_reg_handle_register(nua_t *nua, sofia_profile_t *profile, nua_hand
 	uint8_t stale = 0, forbidden = 0;
 	auth_res_t auth_res = AUTH_OK;
 	long exptime = 300;
-	switch_event_t *event;
 	const char *rpid = "unknown";
 	const char *display = "\"user\"";
 	char network_ip[80];
@@ -1454,7 +1458,7 @@ uint8_t sofia_reg_handle_register(nua_t *nua, sofia_profile_t *profile, nua_hand
 
 		if (auth_res != AUTH_OK && auth_res != AUTH_RENEWED && !stale) {
 			if (auth_res == AUTH_FORBIDDEN) {
-				nua_respond(nh, SIP_403_FORBIDDEN, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
+				nua_respond(nh, SIP_503_SERVICE_UNAVAILABLE, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
 				forbidden = 1;
 			} else {
 				nua_respond(nh, SIP_401_UNAUTHORIZED, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
@@ -1692,28 +1696,6 @@ uint8_t sofia_reg_handle_register(nua_t *nua, sofia_profile_t *profile, nua_hand
 		}
 
 	} else {
-		int send = 1;
-
-		if (multi_reg) {
-			if (sofia_reg_reg_count(profile, to_user, sub_host) > 0) {
-				send = 0;
-			}
-		}
-
-		if (send && switch_event_create(&event, SWITCH_EVENT_PRESENCE_IN) == SWITCH_STATUS_SUCCESS) {
-			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "proto", SOFIA_CHAT_PROTO);
-			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "rpid", rpid);
-			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "login", profile->url);
-			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "user-agent",
-										   (sip && sip->sip_user_agent) ? sip->sip_user_agent->g_string : "unknown");
-			switch_event_add_header(event, SWITCH_STACK_BOTTOM, "from", "%s@%s", to_user, sub_host);
-			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "status", "Unregistered");
-			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "presence-source", "register");
-			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM, "event_type", "presence");
-			switch_event_fire(&event);
-		}
-		
-
 		if (multi_reg) {
 			char *icontact, *p;
 			icontact = sofia_glue_get_url_from_contact(contact_str, 1);
@@ -1770,6 +1752,7 @@ uint8_t sofia_reg_handle_register(nua_t *nua, sofia_profile_t *profile, nua_hand
 						switch_event_add_header(s_mwi_event, SWITCH_STACK_BOTTOM, "Message-Account", "sip:%s@%s", mwi_user, mwi_host);
 						switch_event_add_header_string(s_mwi_event, SWITCH_STACK_BOTTOM, "VM-Sofia-Profile", profile->name);
 						switch_event_add_header_string(s_mwi_event, SWITCH_STACK_BOTTOM, "VM-Call-ID", call_id);
+						switch_event_add_header(s_mwi_event, SWITCH_STACK_BOTTOM, "VM-User", "%s@%s", to_user, reg_host);
 					}
 				}
 
@@ -1788,16 +1771,6 @@ uint8_t sofia_reg_handle_register(nua_t *nua, sofia_profile_t *profile, nua_hand
 							switch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, "alt_event_type", "dialog");
 							switch_event_fire(&s_event);
 						}
-					} else {
-						if (switch_event_create(&s_event, SWITCH_EVENT_PRESENCE_IN) == SWITCH_STATUS_SUCCESS) {
-							switch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, "proto", SOFIA_CHAT_PROTO);
-							switch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, "login", profile->name);
-							switch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, "presence-source", "register");
-							switch_event_add_header(s_event, SWITCH_STACK_BOTTOM, "from", "%s@%s", to_user, sub_host);
-							switch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, "rpid", "unknown");
-							switch_event_add_header_string(s_event, SWITCH_STACK_BOTTOM, "status", "Registered");
-							switch_event_fire(&s_event);
-						}		
 					}
 				}
 			} else {
@@ -1921,7 +1894,7 @@ void sofia_reg_handle_sip_i_register(nua_t *nua, sofia_profile_t *profile, nua_h
 	}
 
 	if (!(profile->mflags & MFLAG_REGISTER)) {
-		nua_respond(nh, SIP_403_FORBIDDEN, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
+		nua_respond(nh, SIP_503_SERVICE_UNAVAILABLE, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
 		goto end;
 	}
 
@@ -1985,7 +1958,7 @@ void sofia_reg_handle_sip_i_register(nua_t *nua, sofia_profile_t *profile, nua_h
 			type = REG_AUTO_REGISTER;
 		} else if (!ok) {
 			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "IP %s Rejected by register acl \"%s\"\n", network_ip, profile->reg_acl[x]);
-			nua_respond(nh, SIP_403_FORBIDDEN, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
+			nua_respond(nh, SIP_503_SERVICE_UNAVAILABLE, NUTAG_WITH_THIS_MSG(de->data->e_msg), TAG_END());
 			goto end;
 		}
 	}
diff --git a/src/mod/event_handlers/mod_kazoo/Makefile.in b/src/mod/event_handlers/mod_kazoo/Makefile.in
new file mode 100644
index 0000000..92b9e69
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/Makefile.in
@@ -0,0 +1,8 @@
+BASE=../../../..
+
+LOCAL_SOURCES=kazoo_utils.c kazoo_node.c kazoo_event_stream.c kazoo_fetch_agent.c
+LOCAL_OBJS=kazoo_utils.o kazoo_node.o kazoo_event_stream.o kazoo_fetch_agent.o
+LOCAL_CFLAGS= @ERLANG_CFLAGS@ -D_REENTRANT -I$(BASE)/libs/apr/include
+LOCAL_LDFLAGS= @ERLANG_LDFLAGS@
+
+include $(BASE)/build/modmake.rules
diff --git a/src/mod/event_handlers/mod_kazoo/conf/autoload_configs/kazoo.conf.xml b/src/mod/event_handlers/mod_kazoo/conf/autoload_configs/kazoo.conf.xml
new file mode 100644
index 0000000..57eb07f
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/conf/autoload_configs/kazoo.conf.xml
@@ -0,0 +1,155 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<configuration name="kazoo.conf" description="General purpose Erlang c-node produced to better fit the Kazoo project">
+    <settings>
+        <param name="listen-ip" value="0.0.0.0" />
+        <param name="listen-port" value="8031" />
+        <param name="cookie-file" value="/etc/freeswitch/autoload_configs/.erlang.cookie" />
+        <param name="shortname" value="false" />
+        <param name="nodename" value="freeswitch" />
+		<!--<param name="kazoo-var-prefix" value="ecallmgr" />-->
+        <!--<param name="compat-rel" value="12"/> -->
+    </settings>
+    <event-filter type="whitelist">
+        <header name="Acquired-UUID" />
+        <header name="action" />
+        <header name="Action" />
+        <header name="alt_event_type" />
+        <header name="Answer-State" />
+        <header name="Application" />
+        <header name="Application-Data" />
+        <header name="Application-Name" />
+        <header name="Application-Response" />
+        <header name="att_xfer_replaced_by" />
+        <header name="Auth-Method" />
+        <header name="Auth-Realm" />
+        <header name="Auth-User" />
+        <header name="Bridge-A-Unique-ID" />
+        <header name="Bridge-B-Unique-ID" />
+        <header name="Call-Direction" />
+        <header name="Caller-Callee-ID-Name" />
+        <header name="Caller-Callee-ID-Number" />
+        <header name="Caller-Caller-ID-Name" />
+        <header name="Caller-Caller-ID-Number" />
+        <header name="Caller-Context" />
+        <header name="Caller-Controls" />
+        <header name="Caller-Destination-Number" />
+        <header name="Caller-Dialplan" />
+        <header name="Caller-Network-Addr" />
+        <header name="Caller-Unique-ID" />
+        <header name="Call-ID" />
+        <header name="Channel-Call-State" />
+        <header name="Channel-Call-UUID" />
+        <header name="Channel-Presence-ID" />
+        <header name="Channel-State" />
+        <header name="Chat-Permissions" />
+        <header name="Conference-Name" />
+        <header name="Conference-Profile-Name" />
+        <header name="Conference-Unique-ID" />
+        <header name="contact" />
+        <header name="Detected-Tone" />
+        <header name="dialog_state" />
+        <header name="direction" />
+        <header name="Distributed-From" />
+        <header name="DTMF-Digit" />
+        <header name="DTMF-Duration" />
+        <header name="Event-Date-Timestamp" />
+        <header name="Event-Name" />
+        <header name="Event-Subclass" />
+        <header name="expires" />
+        <header name="Expires" />
+        <header name="Ext-SIP-IP" />
+        <header name="File" />
+        <header name="FreeSWITCH-Hostname" />
+        <header name="from" />
+        <header name="Hunt-Destination-Number" />
+        <header name="ip" />
+        <header name="Message-Account" />
+        <header name="metadata" />
+        <header name="old_node_channel_uuid" />
+        <header name="Other-Leg-Callee-ID-Name" />
+        <header name="Other-Leg-Callee-ID-Number" />
+        <header name="Other-Leg-Caller-ID-Name" />
+        <header name="Other-Leg-Caller-ID-Number" />
+        <header name="Other-Leg-Destination-Number" />
+        <header name="Other-Leg-Direction" />
+        <header name="Other-Leg-Unique-ID" />
+        <header name="Participant-Type" />
+        <header name="Path" />
+        <header name="profile_name" />
+        <header name="Profiles" />
+        <header name="proto-specific-event-name" />
+        <header name="Raw-Application-Data" />
+        <header name="realm" />
+        <header name="Resigning-UUID" />
+        <header name="set" />
+        <header name="sip_auto_answer" />
+        <header name="sip_auth_method" />
+        <header name="sip_from_host" />
+        <header name="sip_from_user" />
+        <header name="sip_to_host" />
+        <header name="sip_to_user" />
+        <header name="sub-call-id" />
+        <header name="technology" />
+        <header name="to" />
+        <header name="Unique-ID" />
+        <header name="URL" />
+        <header name="username" />
+        <header name="variable_channel_is_moving" />
+        <header name="variable_collected_digits" />
+        <header name="variable_current_application" />
+        <header name="variable_current_application_data" />
+        <header name="variable_domain_name" />
+        <header name="variable_effective_caller_id_name" />
+        <header name="variable_effective_caller_id_number" />
+        <header name="variable_fax_bad_rows" />
+        <header name="variable_fax_document_total_pages" />
+        <header name="variable_fax_document_transferred_pages" />
+        <header name="variable_fax_ecm_used" />
+        <header name="variable_fax_result_code" />
+        <header name="variable_fax_result_text" />
+        <header name="variable_fax_success" />
+        <header name="variable_fax_transfer_rate" />
+        <header name="variable_holding_uuid" />
+        <header name="variable_hold_music" />
+        <header name="variable_media_group_id" />
+        <header name="variable_originate_disposition" />
+        <header name="variable_playback_terminator_used" />
+        <header name="variable_presence_id" />
+        <header name="variable_record_ms" />
+        <header name="variable_recovered" />
+        <header name="variable_silence_hits_exhausted" />
+        <header name="variable_sip_auth_realm" />
+        <header name="variable_sip_from_host" />
+        <header name="variable_sip_from_user" />
+        <header name="variable_sip_h_X-AUTH-IP" />
+        <header name="variable_sip_received_ip" />
+        <header name="variable_sip_to_host" />
+        <header name="variable_sip_to_user" />
+        <header name="variable_sofia_profile_name" />
+        <header name="variable_transfer_history" />
+        <header name="variable_user_name" />
+        <header name="variable_endpoint_disposition" />
+        <header name="variable_originate_disposition" />
+        <header name="variable_bridge_hangup_cause" />
+        <header name="variable_hangup_cause" />
+        <header name="variable_last_bridge_proto_specific_hangup_cause" />
+        <header name="variable_proto_specific_hangup_cause" />
+        <header name="VM-Call-ID" />
+        <header name="VM-sub-call-id" />
+        <header name="whistle_application_name" />
+        <header name="whistle_application_response" />
+        <header name="whistle_event_name" />
+        <header name="sip_auto_answer_notify" />
+        <header name="eavesdrop_group" />
+        <header name="origination_caller_id_name" />
+        <header name="origination_caller_id_number" />
+        <header name="origination_callee_id_name" />
+        <header name="origination_callee_id_number" />
+        <header name="sip_auth_username" />
+        <header name="sip_auth_password" />
+        <header name="effective_caller_id_name" />
+        <header name="effective_caller_id_number" />
+        <header name="effective_callee_id_name" />
+        <header name="effective_callee_id_number" />
+    </event-filter>
+</configuration>
diff --git a/src/mod/event_handlers/mod_kazoo/kazoo_event_stream.c b/src/mod/event_handlers/mod_kazoo/kazoo_event_stream.c
new file mode 100644
index 0000000..79bf434
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/kazoo_event_stream.c
@@ -0,0 +1,534 @@
+/*
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2012, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Karl Anderson <karl@2600hz.com>
+ * Darren Schreiber <darren@2600hz.com>
+ *
+ *
+ * kazoo_event_streams.c -- Event Publisher
+ *
+ */
+#include "mod_kazoo.h"
+
+/* Blatantly repurposed from switch_eventc */
+static char *my_dup(const char *s)
+{
+	size_t len = strlen(s) + 1;
+	void *new = malloc(len);
+	switch_assert(new);
+
+	return (char *) memcpy(new, s, len);
+}
+
+#ifndef DUP
+#define DUP(str) my_dup(str)
+#endif
+
+static switch_status_t kazoo_event_dup(switch_event_t **clone, switch_event_t *event, switch_event_t *filter) {
+	switch_event_header_t *header;
+
+	if (switch_event_create_subclass(clone, SWITCH_EVENT_CLONE, event->subclass_name) != SWITCH_STATUS_SUCCESS) {
+		return SWITCH_STATUS_GENERR;
+	}
+
+	(*clone)->event_id = event->event_id;
+	(*clone)->event_user_data = event->event_user_data;
+	(*clone)->bind_user_data = event->bind_user_data;
+	(*clone)->flags = event->flags;
+
+	for (header = event->headers; header; header = header->next) {
+		if (event->subclass_name && !strcmp(header->name, "Event-Subclass")) {
+			continue;
+		}
+
+		/* TODO: switch_event_get_header_ptr is not the most efficient way to check for existence... */
+		if (strncmp(header->name, globals.kazoo_var_prefix, globals.var_prefix_length)
+			&& filter 
+			&& !switch_event_get_header_ptr(filter, header->name)) 
+		{
+			continue;
+		}
+
+        if (header->idx) {
+            int i;
+            for (i = 0; i < header->idx; i++) {
+                switch_event_add_header_string(*clone, SWITCH_STACK_PUSH, header->name, header->array[i]);
+            }
+        } else {
+            switch_event_add_header_string(*clone, SWITCH_STACK_BOTTOM, header->name, header->value);
+        }
+    }
+	
+    if (event->body) {
+        (*clone)->body = DUP(event->body);
+    }
+	
+    (*clone)->key = event->key;
+	
+    return SWITCH_STATUS_SUCCESS;
+}
+
+static void event_handler(switch_event_t *event) {
+	switch_event_t *clone = NULL;
+	ei_event_stream_t *event_stream = (ei_event_stream_t *) event->bind_user_data;
+
+	/* if mod_kazoo or the event stream isn't running dont push a new event */
+	if (!switch_test_flag(event_stream, LFLAG_RUNNING) || !switch_test_flag(&globals, LFLAG_RUNNING)) {
+		return;
+	}
+
+	/* try to clone the event and push it to the event stream thread */
+	/* TODO: someday maybe the filter comes from the event_stream (set during init only)
+	 * and is per-binding so we only send headers that a process requests */
+	if (kazoo_event_dup(&clone, event, globals.event_filter) == SWITCH_STATUS_SUCCESS) {
+		if (switch_queue_trypush(event_stream->queue, clone) != SWITCH_STATUS_SUCCESS) {
+			/* if we couldn't place the cloned event into the listeners */
+			/* event queue make sure we destroy it, real good like */
+			switch_event_destroy(&clone);
+		}
+	} else {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Memory error: Have a good trip? See you next fall!\n");
+	}
+}
+
+static void *SWITCH_THREAD_FUNC event_stream_loop(switch_thread_t *thread, void *obj) {
+    ei_event_stream_t *event_stream = (ei_event_stream_t *) obj;
+	ei_event_binding_t *event_binding;
+	switch_sockaddr_t *sa;
+	uint16_t port;
+    char ipbuf[25];
+    const char *ip_addr;
+	void *pop;
+
+	switch_atomic_inc(&globals.threads);
+
+	switch_assert(event_stream != NULL);
+
+	/* figure out what socket we just opened */
+	switch_socket_addr_get(&sa, SWITCH_FALSE, event_stream->acceptor);
+	port = switch_sockaddr_get_port(sa);
+    ip_addr = switch_get_addr(ipbuf, sizeof(ipbuf), sa);
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Starting erlang event stream %p on %s:%u for %s <%d.%d.%d>\n"
+					  ,(void *)event_stream, ip_addr, port, event_stream->pid.node, event_stream->pid.creation
+					  ,event_stream->pid.num, event_stream->pid.serial);
+
+	while (switch_test_flag(event_stream, LFLAG_RUNNING) && switch_test_flag(&globals, LFLAG_RUNNING)) {
+		const switch_pollfd_t *fds;
+		int32_t numfds;
+
+		/* check if a new connection is pending */
+		if (switch_pollset_poll(event_stream->pollset, 0, &numfds, &fds) == SWITCH_STATUS_SUCCESS) {
+			for (int32_t i = 0; i < numfds; i++) {
+				switch_socket_t *newsocket;
+
+				/* accept the new client connection */
+				if (switch_socket_accept(&newsocket, event_stream->acceptor, event_stream->pool) == SWITCH_STATUS_SUCCESS) {
+					switch_sockaddr_t *sa;
+					char remotebuf[25], localbuf[25];
+
+                    if (switch_socket_opt_set(newsocket, SWITCH_SO_NONBLOCK, TRUE)) {
+                        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Couldn't set socket as non-blocking\n");
+                    }
+
+                    if (switch_socket_opt_set(newsocket, SWITCH_SO_TCP_NODELAY, 1)) {
+                        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Couldn't disable Nagle.\n");
+                    }
+
+					/* figure out where the new client is */
+					switch_socket_addr_get(&sa, SWITCH_TRUE, newsocket);					
+					port = switch_sockaddr_get_port(sa);
+					ip_addr = switch_get_addr(ipbuf, sizeof (ipbuf), sa);
+
+					/* close the current client, if there is one */
+					close_socket(&event_stream->socket);
+					
+					switch_mutex_lock(event_stream->socket_mutex); 
+					/* start sending to the new client */
+					event_stream->socket = newsocket;
+
+					switch_socket_addr_get(&sa, SWITCH_FALSE, newsocket);
+					event_stream->remote_port = switch_sockaddr_get_port(sa);
+					event_stream->remote_ip = switch_get_addr(remotebuf, sizeof (remotebuf), sa);
+					
+					switch_socket_addr_get(&sa, SWITCH_TRUE, newsocket);
+					event_stream->local_port = switch_sockaddr_get_port(sa);
+					event_stream->local_ip = switch_get_addr(localbuf, sizeof (localbuf), sa);
+
+					event_stream->connected = SWITCH_TRUE;
+					switch_mutex_unlock(event_stream->socket_mutex);
+
+					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Erlang event stream %p client %s:%u\n", (void *)event_stream, event_stream->remote_ip, event_stream->remote_port);
+				}
+			}
+		}
+
+		/* if there was an event waiting in our queue send it to the client */
+		if (switch_queue_pop_timeout(event_stream->queue, &pop, 500000) == SWITCH_STATUS_SUCCESS) {
+			switch_event_t *event = (switch_event_t *) pop;
+
+ 			if (event_stream->socket) {
+				ei_x_buff ebuf;
+				char high, low;
+				switch_size_t size = 1;
+
+				ei_x_new_with_version(&ebuf);
+				ei_encode_switch_event(&ebuf, event);
+
+				high = ebuf.index >> 8;
+				low = ebuf.index & 0xFF;
+
+				/* big-endian length, not amazingly efficient but functional */
+				switch_socket_send(event_stream->socket, &high, &size);
+				switch_socket_send(event_stream->socket, &low, &size);
+
+				size = (switch_size_t)ebuf.index;
+				switch_socket_send(event_stream->socket, ebuf.buff, &size);
+
+				ei_x_free(&ebuf);
+			}
+
+			switch_event_destroy(&event);
+		}
+	}
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Shutting down erlang event stream %p\n", (void *)event_stream);
+
+	/* unbind from the system events */
+	event_binding = event_stream->bindings;
+	while(event_binding != NULL) {
+		switch_event_unbind(&event_binding->node);
+		event_binding = event_binding->next;
+	}
+	event_stream->bindings = NULL;
+	
+	/* clear and destroy any remaining queued events */
+	while (switch_queue_trypop(event_stream->queue, &pop) == SWITCH_STATUS_SUCCESS) {
+		switch_event_t *event = (switch_event_t *) pop;
+		switch_event_destroy(&event);		
+	}
+	
+	/* remove the acceptor pollset */
+	switch_pollset_remove(event_stream->pollset, event_stream->pollfd);
+	
+	/* close any open sockets */
+	close_socket(&event_stream->acceptor);
+
+	switch_mutex_lock(event_stream->socket_mutex);
+	event_stream->connected = SWITCH_FALSE;
+	close_socket(&event_stream->socket);
+	switch_mutex_unlock(event_stream->socket_mutex);
+
+	switch_mutex_destroy(event_stream->socket_mutex);
+	
+	/* clean up the memory */
+	switch_core_destroy_memory_pool(&event_stream->pool);
+
+	switch_atomic_dec(&globals.threads);
+
+	return NULL;
+}
+
+ei_event_stream_t *new_event_stream(ei_event_stream_t **event_streams, const erlang_pid *from) {
+	switch_thread_t *thread;
+	switch_threadattr_t *thd_attr = NULL;
+	switch_memory_pool_t *pool = NULL;
+	ei_event_stream_t *event_stream;
+
+	/* create memory pool for this event stream */
+	if (switch_core_new_memory_pool(&pool) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Out of memory: How many Alzheimer's patients does it take to screw in a light bulb? To get to the other side.\n");
+		return NULL;
+	}
+	
+	/* from the memory pool, allocate the event stream structure */
+	if (!(event_stream = switch_core_alloc(pool, sizeof (*event_stream)))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Out of memory: I may have Alzheimers but at least I dont have Alzheimers.\n");
+		return NULL;
+	}
+
+	/* prepare the event stream */
+	memset(event_stream, 0, sizeof(*event_stream));
+	event_stream->bindings = NULL;
+	event_stream->pool = pool;
+	event_stream->connected = SWITCH_FALSE;
+	memcpy(&event_stream->pid, from, sizeof(erlang_pid));
+	switch_queue_create(&event_stream->queue, MAX_QUEUE_LEN, pool);
+
+	/* create a socket for accepting the event stream client */
+    if (!(event_stream->acceptor = create_socket(pool))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Like car accidents, most hardware problems are due to driver error.\n");
+		/* TODO: clean up */
+        return NULL;
+    }
+
+	if (switch_socket_opt_set(event_stream->acceptor, SWITCH_SO_NONBLOCK, TRUE)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Hey, it compiles!\n");
+		/* TODO: clean up */
+        return NULL;
+	}
+
+	/* create a pollset so we can efficiently check for new client connections */
+	if (switch_pollset_create(&event_stream->pollset, 1000, pool, 0) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "My software never has bugs. It just develops random features.\n");
+		/* TODO: clean up */
+        return NULL;
+	}
+	
+	switch_socket_create_pollfd(&event_stream->pollfd, event_stream->acceptor, SWITCH_POLLIN | SWITCH_POLLERR, NULL, pool);
+	if (switch_pollset_add(event_stream->pollset, event_stream->pollfd) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "If you saw a heat wave, would you wave back?\n");
+		/* TODO: clean up */
+        return NULL;
+	}
+
+	switch_mutex_init(&event_stream->socket_mutex, SWITCH_MUTEX_DEFAULT, pool);
+
+	/* add the new event stream to the link list
+	 * since the event streams link list is only 
+	 * accessed from the same thread no locks
+	 * are required */
+	if (!*event_streams) {
+		*event_streams = event_stream;
+	} else {
+		event_stream->next = *event_streams;
+		*event_streams = event_stream;
+	}
+
+	/* when we start we are running */
+	switch_set_flag(event_stream, LFLAG_RUNNING);
+
+	switch_threadattr_create(&thd_attr, event_stream->pool);
+	switch_threadattr_detach_set(thd_attr, 1);
+	switch_threadattr_stacksize_set(thd_attr, SWITCH_THREAD_STACKSIZE);
+	switch_thread_create(&thread, thd_attr, event_stream_loop, event_stream, event_stream->pool);
+	
+	return event_stream;
+}
+
+unsigned long get_stream_port(const ei_event_stream_t *event_stream) {
+	switch_sockaddr_t *sa;
+	switch_socket_addr_get(&sa, SWITCH_FALSE, event_stream->acceptor);
+	return (unsigned long) switch_sockaddr_get_port(sa);
+}
+
+ei_event_stream_t *find_event_stream(ei_event_stream_t *event_stream, const erlang_pid *from) {
+	while (event_stream != NULL) {
+		if (ei_compare_pids(&event_stream->pid, from) == SWITCH_STATUS_SUCCESS) {
+			return event_stream;
+		}
+		event_stream = event_stream->next;
+	}
+	
+	return NULL;
+}
+
+switch_status_t remove_event_stream(ei_event_stream_t **event_streams, const erlang_pid *from) {
+	ei_event_stream_t *event_stream, *prev = NULL;
+	int found = 0;
+
+	/* if there are no event bindings there is nothing to do */
+	if (!*event_streams) {
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	/* try to find the event stream for the client process */
+	event_stream = *event_streams;
+	while(event_stream != NULL) {
+		if (ei_compare_pids(&event_stream->pid, from) == SWITCH_STATUS_SUCCESS) {
+			found = 1;
+			break;
+		}
+
+		prev = event_stream;
+		event_stream = event_stream->next;
+	}
+
+	if (found) {
+		/* if we found an event stream remove it from
+		 * from the link list */
+		if (!prev) {
+			*event_streams = event_stream->next;
+		} else {
+			prev->next = event_stream->next;
+		}
+
+		/* stop the event stream thread */
+		switch_clear_flag(event_stream, LFLAG_RUNNING);
+	}
+
+	return SWITCH_STATUS_SUCCESS;	
+}
+
+switch_status_t remove_event_streams(ei_event_stream_t **event_streams) {
+	ei_event_stream_t *event_stream = *event_streams;
+
+	while(event_stream != NULL) {
+		/* stop the event bindings publisher thread */
+		switch_clear_flag(event_stream, LFLAG_RUNNING);
+
+		event_stream = event_stream->next;
+	}
+
+	*event_streams = NULL;
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t add_event_binding(ei_event_stream_t *event_stream, const switch_event_types_t event_type, const char *subclass_name) {
+	ei_event_binding_t *event_binding = event_stream->bindings;
+
+	/* check if the event binding already exists, ignore if so */
+	while(event_binding != NULL) {
+		if (event_binding->type == SWITCH_EVENT_CUSTOM) {
+			if(!strncmp(event_binding->subclass_name, subclass_name, strlen(event_binding->subclass_name))) {
+				return SWITCH_STATUS_SUCCESS;
+			}
+		} else if (event_binding->type == event_type) {
+			return SWITCH_STATUS_SUCCESS;
+		}
+		event_binding = event_binding->next;
+	}
+
+	/* from the event stream memory pool, allocate the event binding structure */
+	if (!(event_binding = switch_core_alloc(event_stream->pool, sizeof (*event_binding)))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Out of random-access memory, attempting write-only memory\n");
+		return SWITCH_STATUS_FALSE;
+	}
+
+	/* prepare the event binding struct */
+	event_binding->type = event_type;
+	if (zstr(subclass_name)) {
+		event_binding->subclass_name = NULL;
+	} else {
+		/* TODO: free strdup? */
+		event_binding->subclass_name = strdup(subclass_name);
+	}
+	event_binding->next = NULL;
+
+	/* bind to the event with a unique ID and capture the event_node pointer */
+	switch_uuid_str(event_binding->id, sizeof(event_binding->id));
+	if (switch_event_bind_removable(event_binding->id, event_type, subclass_name, event_handler, event_stream, &event_binding->node) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unable to bind to event %s %s!\n"
+						  ,switch_event_name(event_binding->type), event_binding->subclass_name ? event_binding->subclass_name : "");
+		return SWITCH_STATUS_GENERR;
+	}
+	
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Adding event binding %s to stream %p for %s <%d.%d.%d>: %s %s\n"
+					  ,event_binding->id, (void *)event_stream, event_stream->pid.node, event_stream->pid.creation
+					  ,event_stream->pid.num, event_stream->pid.serial, switch_event_name(event_binding->type)
+					  ,event_binding->subclass_name ? event_binding->subclass_name : "");
+
+	/* add the new binding to the list */
+	if (!event_stream->bindings) {
+		event_stream->bindings = event_binding;
+	} else {
+		event_binding->next = event_stream->bindings;
+		event_stream->bindings = event_binding;
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t remove_event_binding(ei_event_stream_t *event_stream, const switch_event_types_t event_type, const char *subclass_name) {
+	ei_event_binding_t *event_binding = event_stream->bindings, *prev = NULL;
+	int found = 0;
+
+	/* if there are no bindings then there is nothing to do */
+	if (!event_binding) {
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	/* try to find the event binding specified */
+	while(event_binding != NULL) {
+		if (event_binding->type == SWITCH_EVENT_CUSTOM 
+			&& event_binding->subclass_name == subclass_name) {
+			found = 1;
+			break;
+		} else if (event_binding->type == event_type) {
+			found = 1;
+			break;
+		}
+
+		prev = event_binding;
+		event_binding = event_binding->next;
+	}
+
+	if (found) {
+		/* if the event binding exists, unbind from the system */
+		switch_event_unbind(&event_binding->node);
+
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Removing event binding %s from %p for %s <%d.%d.%d>: %s %s\n"
+						  ,event_binding->id, (void *)event_stream, event_stream->pid.node, event_stream->pid.creation
+						  ,event_stream->pid.num, event_stream->pid.serial, switch_event_name(event_binding->type)
+						  ,event_binding->subclass_name ? event_binding->subclass_name : "");
+
+		/* remove the event binding from the list */
+		if (!prev) {
+			event_stream->bindings = event_binding->next;
+		} else {
+			prev->next = event_binding->next;
+		}
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t remove_event_bindings(ei_event_stream_t *event_stream) {
+	ei_event_binding_t *event_binding = event_stream->bindings;
+
+	/* if there are no bindings then there is nothing to do */
+	if (!event_binding) {
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	/* try to find the event binding specified */
+	while(event_binding != NULL) {
+		/* if the event binding exists, unbind from the system */
+		switch_event_unbind(&event_binding->node);
+
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Removing event binding %s from %p for %s <%d.%d.%d>: %s %s\n"
+						  ,event_binding->id, (void *)event_stream, event_stream->pid.node, event_stream->pid.creation
+						  ,event_stream->pid.num, event_stream->pid.serial, switch_event_name(event_binding->type)
+						  ,event_binding->subclass_name ? event_binding->subclass_name : "");
+
+		event_binding = event_binding->next;
+	}
+	
+	event_stream->bindings = NULL;
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+/* For Emacs:
+ * Local Variables:
+ * mode:c
+ * indent-tabs-mode:t
+ * tab-width:4
+ * c-basic-offset:4
+ * End:
+ * For VIM:
+ * vim:set softtabstop=4 shiftwidth=4 tabstop=4:
+ */
diff --git a/src/mod/event_handlers/mod_kazoo/kazoo_fetch_agent.c b/src/mod/event_handlers/mod_kazoo/kazoo_fetch_agent.c
new file mode 100644
index 0000000..0bcc02a
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/kazoo_fetch_agent.c
@@ -0,0 +1,705 @@
+/*
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2012, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Karl Anderson <karl@2600hz.com>
+ * Darren Schreiber <darren@2600hz.com>
+ *
+ *
+ * kazoo_fetch.c -- XML fetch request handler
+ *
+ */
+#include "mod_kazoo.h"
+
+struct xml_fetch_reply_s {
+	char uuid_str[SWITCH_UUID_FORMATTED_LENGTH + 1];
+	char *xml_str;
+	struct xml_fetch_reply_s *next;
+};
+typedef struct xml_fetch_reply_s xml_fetch_reply_t;
+
+struct fetch_handler_s {
+	erlang_pid pid;
+	struct fetch_handler_s *next;
+};
+typedef struct fetch_handler_s fetch_handler_t;
+
+struct ei_xml_client_s {
+	ei_node_t *ei_node;	
+	fetch_handler_t *fetch_handlers;
+	struct ei_xml_client_s *next;
+};
+typedef struct ei_xml_client_s ei_xml_client_t;
+
+struct ei_xml_agent_s {
+	switch_memory_pool_t *pool;
+	switch_xml_section_t section;
+	switch_thread_rwlock_t *lock;
+	ei_xml_client_t *clients;
+	switch_mutex_t *current_client_mutex;
+	ei_xml_client_t *current_client;
+	switch_mutex_t *replies_mutex;
+	switch_thread_cond_t *new_reply;
+	xml_fetch_reply_t *replies;
+};
+typedef struct ei_xml_agent_s ei_xml_agent_t;
+
+static char *xml_section_to_string(switch_xml_section_t section) {
+	switch(section) {
+	case SWITCH_XML_SECTION_CONFIG:
+		return "configuration";
+	case SWITCH_XML_SECTION_DIRECTORY:
+		return "directory";
+	case SWITCH_XML_SECTION_DIALPLAN:
+		return "dialplan";
+	case SWITCH_XML_SECTION_CHATPLAN:
+		return "chatplan";
+	default:
+		return "unknown";
+	}
+}
+
+static char *expand_vars(char *xml_str) {
+	char *var, *val;
+	char *rp = xml_str; /* read pointer */
+	char *ep, *wp, *buff; /* end pointer, write pointer, write buffer */
+	
+	if (!(strstr(xml_str, "$${"))) {
+		return xml_str;
+	}
+	
+	switch_zmalloc(buff, strlen(xml_str) * 2);
+	wp = buff;
+	ep = buff + (strlen(xml_str) * 2) - 1;
+	
+	while (*rp && wp < ep) {
+		if (*rp == '$' && *(rp + 1) == '$' && *(rp + 2) == '{') {
+			char *e = switch_find_end_paren(rp + 2, '{', '}');
+			
+			if (e) {
+				rp += 3;
+				var = rp;
+				*e++ = '\0';
+				rp = e;
+				
+				if ((val = switch_core_get_variable_dup(var))) {
+					char *p;
+					for (p = val; p && *p && wp <= ep; p++) {
+						*wp++ = *p;
+					}
+					switch_safe_free(val);
+				}
+				continue;
+			}
+		}
+		
+		*wp++ = *rp++;
+	}
+	
+	*wp++ = '\0';
+	
+	switch_safe_free(xml_str);
+	return buff;
+}
+
+static switch_xml_t fetch_handler(const char *section, const char *tag_name, const char *key_name, const char *key_value, switch_event_t *params, void *user_data) {
+	switch_xml_t xml = NULL;
+	switch_uuid_t uuid;
+	switch_time_t now = 0;
+	ei_xml_agent_t *agent = (ei_xml_agent_t *) user_data;
+	ei_xml_client_t *client;
+	fetch_handler_t *fetch_handler;
+	xml_fetch_reply_t reply, *pending, *prev = NULL;
+
+	now = switch_micro_time_now();
+
+	if (!switch_test_flag(&globals, LFLAG_RUNNING)) {
+		return xml;
+	}
+
+	/* read-lock the agent */
+	switch_thread_rwlock_rdlock(agent->lock);
+
+	/* serialize access to current, used to round-robin requests */
+	/* TODO: check globals for round-robin boolean or loop all clients */
+	switch_mutex_lock(agent->current_client_mutex);
+	if (!agent->current_client) {
+		client = agent->clients;
+	} else {
+		client = agent->current_client;
+	}
+	if (client) {
+		agent->current_client = client->next;
+	}
+	switch_mutex_unlock(agent->current_client_mutex);
+
+	/* no client, no work required */
+	if (!client || !client->fetch_handlers) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "No %s XML erlang handler currently available\n"
+						  ,xml_section_to_string(agent->section));
+		switch_thread_rwlock_unlock(agent->lock);
+		return xml;
+	}
+
+	/* prepare the reply collector */
+	switch_uuid_get(&uuid);
+	switch_uuid_format(reply.uuid_str, &uuid);
+	reply.next = NULL;
+	reply.xml_str = NULL;
+
+	/* add our reply placeholder to the replies list */
+	switch_mutex_lock(agent->replies_mutex);
+
+	if (!agent->replies) {
+		agent->replies = &reply;
+	} else {
+		reply.next = agent->replies;
+		agent->replies = &reply;
+	}
+	switch_mutex_unlock(agent->replies_mutex);
+
+	fetch_handler = client->fetch_handlers;
+	while (fetch_handler != NULL) {
+		ei_asynchronous_msg_t *asynchronous_msg;
+
+		switch_malloc(asynchronous_msg, sizeof(*asynchronous_msg));
+		memcpy(&asynchronous_msg->pid, &fetch_handler->pid, sizeof(erlang_pid));
+		
+		ei_x_new_with_version(&asynchronous_msg->ebuf);
+			
+		ei_x_encode_tuple_header(&asynchronous_msg->ebuf, 7);
+		ei_x_encode_atom(&asynchronous_msg->ebuf, "fetch");
+		ei_x_encode_atom(&asynchronous_msg->ebuf, section);
+		_ei_x_encode_string(&asynchronous_msg->ebuf, tag_name ? tag_name : "undefined");
+		_ei_x_encode_string(&asynchronous_msg->ebuf, key_name ? key_name : "undefined");
+		_ei_x_encode_string(&asynchronous_msg->ebuf, key_value ? key_value : "undefined");
+		_ei_x_encode_string(&asynchronous_msg->ebuf, reply.uuid_str);
+		
+		if (params) {
+			ei_encode_switch_event_headers(&asynchronous_msg->ebuf, params);
+		} else {
+			ei_x_encode_empty_list(&asynchronous_msg->ebuf);
+		}
+
+		if (switch_queue_trypush(client->ei_node->asynchronous_msgs, asynchronous_msg) != SWITCH_STATUS_SUCCESS) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Failed to send %s XML request to %s <%d.%d.%d>\n"
+							  ,xml_section_to_string(agent->section)
+							  ,fetch_handler->pid.node
+							  ,fetch_handler->pid.creation
+							  ,fetch_handler->pid.num
+							  ,fetch_handler->pid.serial);
+			ei_x_free(&asynchronous_msg->ebuf);
+			switch_safe_free(asynchronous_msg);
+		} else {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Sending %s XML request (%s) to %s <%d.%d.%d>\n"
+							  ,xml_section_to_string(agent->section)
+							  ,reply.uuid_str
+							  ,fetch_handler->pid.node
+							  ,fetch_handler->pid.creation
+							  ,fetch_handler->pid.num
+							  ,fetch_handler->pid.serial);
+		}
+		
+		fetch_handler = fetch_handler->next;
+	}
+
+	/* wait for a reply (if there isnt already one...amazingly improbable but lets not take shortcuts */
+    switch_mutex_lock(agent->replies_mutex);
+
+	if (!reply.xml_str) {
+		switch_time_t timeout;
+
+		timeout = switch_micro_time_now() + 3000000;
+		while (switch_micro_time_now() < timeout) {
+			/* unlock the replies list and go to sleep, calculate a three second timeout before we started the loop
+			 * plus 100ms to add a little hysteresis between the timeout and the while loop */
+			switch_thread_cond_timedwait(agent->new_reply, agent->replies_mutex, (timeout - switch_micro_time_now() + 100000));
+
+			/* if we woke up (and therefore have locked replies again) check if we got our reply
+			 * otherwise we either timed-out (the while condition will fail) or one of
+			 * our sibling processes got a reply and we should go back to sleep */
+			if (reply.xml_str) {
+				break;
+			}
+		}
+	}
+
+	/* find our reply placeholder in the linked list and remove it */
+	pending = agent->replies;
+	while (pending != NULL) {
+		if (pending->uuid_str == reply.uuid_str) {
+			break;
+		}
+
+		prev = pending;
+		pending = pending->next;
+	}
+	
+	if (pending) {
+		if (!prev) {
+			agent->replies = reply.next;
+		} else {
+			prev->next = reply.next;
+		}
+	}
+
+	/* we are done with the replies link-list */
+	switch_mutex_unlock(agent->replies_mutex);
+
+	/* we are done with the agent, if we are starving the adding/removing clients
+	 * theoretically we could release before locking replies_mutex for the
+	 * conditional signal */
+	switch_thread_rwlock_unlock(agent->lock);
+
+	/* after all that did we get what we were after?! */
+	if (reply.xml_str) {
+		/* HELL YA WE DID */
+		reply.xml_str = expand_vars(reply.xml_str);
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Received %s XML (%s) after %dms: %s\n"
+						  ,xml_section_to_string(agent->section)
+						  ,reply.uuid_str
+						  ,(unsigned int) (switch_micro_time_now() - now) / 1000
+						  ,reply.xml_str);
+
+		xml = switch_xml_parse_str_dynamic(reply.xml_str, SWITCH_FALSE);
+	} else {
+		/* facepalm */
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "Request for %s XML (%s) timed-out after %dms\n"
+						  ,xml_section_to_string(agent->section)
+						  ,reply.uuid_str
+						  ,(unsigned int) (switch_micro_time_now() - now) / 1000);
+	}
+
+	return xml;
+}
+
+static switch_status_t bind_fetch_agent(switch_xml_section_t section, switch_xml_binding_t **binding) {
+	switch_memory_pool_t *pool = NULL;
+	ei_xml_agent_t *agent;
+
+	/* create memory pool for this xml search binging (lives for duration of mod_kazoo runtime) */
+	if (switch_core_new_memory_pool(&pool) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Out of memory: They're not people; they're hippies!\n");
+		return SWITCH_STATUS_MEMERR;
+	}
+
+	/* allocate some memory to store the fetch bindings for this section */
+    if (!(agent = switch_core_alloc(pool, sizeof (*agent)))) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Out of memory: Oh, Jesus tap-dancing Christ!\n");
+        return SWITCH_STATUS_MEMERR;
+    }
+
+	/* try to bind to the switch */
+	if (switch_xml_bind_search_function_ret(fetch_handler, section, agent, binding) != SWITCH_STATUS_SUCCESS) {
+		switch_core_destroy_memory_pool(&pool);
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Could not bind to FreeSWITCH %s XML requests\n"
+						  ,xml_section_to_string(section));
+		return SWITCH_STATUS_GENERR;
+	}
+
+	agent->pool = pool;
+	agent->section = section;
+	switch_thread_rwlock_create(&agent->lock, pool);
+	agent->clients = NULL;
+	switch_mutex_init(&agent->current_client_mutex, SWITCH_MUTEX_DEFAULT, pool);
+	agent->current_client = NULL;
+	switch_mutex_init(&agent->replies_mutex, SWITCH_MUTEX_DEFAULT, pool);
+	switch_thread_cond_create(&agent->new_reply, pool);
+	agent->replies = NULL;
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Bound to %s XML requests\n"
+					  ,xml_section_to_string(section));
+		
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t unbind_fetch_agent(switch_xml_binding_t **binding) {
+	ei_xml_agent_t *agent;
+	ei_xml_client_t *client;
+
+	/* get a pointer to our user_data */
+	agent = (ei_xml_agent_t *)switch_xml_get_binding_user_data(*binding);
+
+	/* unbind from the switch */
+	switch_xml_unbind_search_function(binding);
+	
+	/* LOCK ALL THE THINGS */
+	switch_thread_rwlock_wrlock(agent->lock);
+	switch_mutex_lock(agent->current_client_mutex);
+	switch_mutex_lock(agent->replies_mutex);
+
+	/* cleanly destroy each client */
+	client = agent->clients;
+	while(client != NULL) {
+		ei_xml_client_t *tmp_client = client;
+		fetch_handler_t *fetch_handler;
+		
+		fetch_handler = client->fetch_handlers;
+		while(fetch_handler != NULL) {
+			fetch_handler_t *tmp_fetch_handler = fetch_handler;
+
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Removed %s XML handler %s <%d.%d.%d>\n"
+							  ,xml_section_to_string(agent->section)
+							  ,fetch_handler->pid.node
+							  ,fetch_handler->pid.creation
+							  ,fetch_handler->pid.num
+							  ,fetch_handler->pid.serial);
+
+			fetch_handler = fetch_handler->next;
+			switch_safe_free(tmp_fetch_handler);
+		}
+
+		client = client->next;
+		switch_safe_free(tmp_client);
+	}
+
+	/* keep the pointers clean, even if its just for a moment */
+	agent->clients = NULL;
+	agent->current_client = NULL;
+
+	/* release the locks! */
+	switch_thread_rwlock_unlock(agent->lock);
+	switch_mutex_unlock(agent->current_client_mutex);
+	switch_mutex_unlock(agent->replies_mutex);	
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Unbound from %s XML requests\n"
+					  ,xml_section_to_string(agent->section));
+	
+	/* cleanly destroy the bindings */
+	switch_thread_rwlock_destroy(agent->lock);
+	switch_mutex_destroy(agent->current_client_mutex);
+	switch_mutex_destroy(agent->replies_mutex);
+	switch_thread_cond_destroy(agent->new_reply);
+	switch_core_destroy_memory_pool(&agent->pool);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t remove_xml_client(ei_node_t *ei_node, switch_xml_binding_t *binding) {
+	ei_xml_agent_t *agent;	
+	ei_xml_client_t *client, *prev = NULL;
+	int found = 0;
+
+	agent = (ei_xml_agent_t *)switch_xml_get_binding_user_data(binding);
+
+	/* write-lock the agent */
+	switch_thread_rwlock_wrlock(agent->lock);
+
+	client = agent->clients; 
+	while (client != NULL) {
+		if (client->ei_node == ei_node) {
+			found = 1;
+			break;
+		}
+		
+		prev = client;
+		client = client->next;
+	}
+
+	if (found) {
+		fetch_handler_t *fetch_handler;
+		
+		if (!prev) {
+			agent->clients = client->next;
+		} else {
+			prev->next = client->next;
+		}
+
+		/* the mutex lock is not required since we have the write lock
+		 * but hey its fun and safe so do it anyway */
+		switch_mutex_lock(agent->current_client_mutex);
+		if (agent->current_client == client) {
+			agent->current_client = agent->clients;
+		}
+		switch_mutex_unlock(agent->current_client_mutex);
+		
+		fetch_handler = client->fetch_handlers;
+		while(fetch_handler != NULL) {
+			fetch_handler_t *tmp_fetch_handler = fetch_handler;
+
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Removed %s XML handler %s <%d.%d.%d>\n"
+							  ,xml_section_to_string(agent->section)
+							  ,fetch_handler->pid.node
+							  ,fetch_handler->pid.creation
+							  ,fetch_handler->pid.num
+							  ,fetch_handler->pid.serial);
+
+			fetch_handler = fetch_handler->next;
+			switch_safe_free(tmp_fetch_handler);
+		}
+
+		switch_safe_free(client);
+	}
+
+	switch_thread_rwlock_unlock(agent->lock);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static ei_xml_client_t *add_xml_client(ei_node_t *ei_node, ei_xml_agent_t *agent) {
+    ei_xml_client_t *client;
+
+	switch_malloc(client, sizeof(*client));
+
+	client->ei_node = ei_node;
+	client->fetch_handlers = NULL;
+	client->next = NULL;
+
+	if (agent->clients) {
+		client->next = agent->clients;
+	}
+
+	agent->clients = client;
+
+	return client;
+}
+
+static ei_xml_client_t *find_xml_client(ei_node_t *ei_node, ei_xml_agent_t *agent) {
+    ei_xml_client_t *client;
+
+	client = agent->clients;
+	while (client != NULL) {
+		if (client->ei_node == ei_node) {
+			return client;
+		}
+
+		client = client->next;
+	}
+
+	return NULL;		
+}
+
+static switch_status_t remove_fetch_handler(ei_node_t *ei_node, erlang_pid *from, switch_xml_binding_t *binding) {
+	ei_xml_agent_t *agent;
+	ei_xml_client_t *client;
+	fetch_handler_t *fetch_handler, *prev = NULL;
+	int found = 0;
+
+	agent = (ei_xml_agent_t *)switch_xml_get_binding_user_data(binding);
+	
+    /* write-lock the agent */
+    switch_thread_rwlock_wrlock(agent->lock);
+
+	if (!(client = find_xml_client(ei_node, agent))) {
+		switch_thread_rwlock_unlock(agent->lock);
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	fetch_handler = client->fetch_handlers;
+	while (fetch_handler != NULL) {
+		if (ei_compare_pids(&fetch_handler->pid, from) == SWITCH_STATUS_SUCCESS) {
+			found = 1;
+			break;
+		}
+
+		prev = fetch_handler;
+		fetch_handler = fetch_handler->next;
+	}
+
+	if (found) {
+		if (!prev) {
+			client->fetch_handlers = fetch_handler->next;
+		} else {
+			prev->next = fetch_handler->next;
+		}
+		
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Removed %s XML handler %s <%d.%d.%d>\n"
+						  ,xml_section_to_string(agent->section)
+						  ,fetch_handler->pid.node
+						  ,fetch_handler->pid.creation
+						  ,fetch_handler->pid.num
+						  ,fetch_handler->pid.serial);
+		
+		switch_safe_free(fetch_handler);
+	}
+
+	switch_thread_rwlock_unlock(agent->lock);
+	return SWITCH_STATUS_SUCCESS;	
+}
+
+static switch_status_t handle_api_command_stream(ei_node_t *ei_node, switch_stream_handle_t *stream, switch_xml_binding_t *binding) {
+	ei_xml_agent_t *agent;
+    ei_xml_client_t *client;
+
+	if (!binding) {
+		return SWITCH_STATUS_GENERR;
+	}
+
+	agent = (ei_xml_agent_t *)switch_xml_get_binding_user_data(binding);
+
+	/* read-lock the agent */
+	switch_thread_rwlock_rdlock(agent->lock);
+	client = agent->clients;
+	while (client != NULL) {
+		if (client->ei_node == ei_node) {
+			fetch_handler_t *fetch_handler;
+			fetch_handler = client->fetch_handlers;
+			while (fetch_handler != NULL) {
+				stream->write_function(stream, "XML %s handler <%d.%d.%d>\n"
+									   ,xml_section_to_string(agent->section)
+									   ,fetch_handler->pid.creation
+									   ,fetch_handler->pid.num
+									   ,fetch_handler->pid.serial);
+				fetch_handler = fetch_handler->next;
+			}
+			break;
+		}
+
+		client = client->next;
+	}
+	switch_thread_rwlock_unlock(agent->lock);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t bind_fetch_agents() {
+	bind_fetch_agent(SWITCH_XML_SECTION_CONFIG, &globals.config_fetch_binding);
+	bind_fetch_agent(SWITCH_XML_SECTION_DIRECTORY, &globals.directory_fetch_binding);
+	bind_fetch_agent(SWITCH_XML_SECTION_DIALPLAN, &globals.dialplan_fetch_binding);
+	bind_fetch_agent(SWITCH_XML_SECTION_CHATPLAN, &globals.chatplan_fetch_binding);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t unbind_fetch_agents() {
+	unbind_fetch_agent(&globals.config_fetch_binding);
+	unbind_fetch_agent(&globals.directory_fetch_binding);
+	unbind_fetch_agent(&globals.dialplan_fetch_binding);
+	unbind_fetch_agent(&globals.chatplan_fetch_binding);
+	
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t remove_xml_clients(ei_node_t *ei_node) {
+	remove_xml_client(ei_node, globals.config_fetch_binding);
+	remove_xml_client(ei_node, globals.directory_fetch_binding);
+	remove_xml_client(ei_node, globals.dialplan_fetch_binding);
+	remove_xml_client(ei_node, globals.chatplan_fetch_binding);
+	
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t add_fetch_handler(ei_node_t *ei_node, erlang_pid *from, switch_xml_binding_t *binding) {
+	ei_xml_agent_t *agent;
+	ei_xml_client_t *client;
+	fetch_handler_t *fetch_handler;
+
+	agent = (ei_xml_agent_t *)switch_xml_get_binding_user_data(binding);
+	
+    /* write-lock the agent */
+    switch_thread_rwlock_wrlock(agent->lock);
+
+	if (!(client = find_xml_client(ei_node, agent))) {
+		client = add_xml_client(ei_node, agent);
+	}
+
+	fetch_handler = client->fetch_handlers;
+    while (fetch_handler != NULL) {
+		if (ei_compare_pids(&fetch_handler->pid, from) == SWITCH_STATUS_SUCCESS) {
+			switch_thread_rwlock_unlock(agent->lock);
+            return SWITCH_STATUS_SUCCESS;
+        }
+        fetch_handler = fetch_handler->next;
+    }
+
+	switch_malloc(fetch_handler, sizeof(*fetch_handler));
+
+	memcpy(&fetch_handler->pid, from, sizeof(erlang_pid));;
+
+	fetch_handler->next = NULL;
+	if (client->fetch_handlers) {
+		fetch_handler->next = client->fetch_handlers;
+	}
+
+	client->fetch_handlers = fetch_handler;
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Added %s XML handler %s <%d.%d.%d>\n"
+					  ,xml_section_to_string(agent->section)
+					  ,fetch_handler->pid.node
+					  ,fetch_handler->pid.creation
+					  ,fetch_handler->pid.num
+					  ,fetch_handler->pid.serial);
+
+	switch_thread_rwlock_unlock(agent->lock);
+
+	ei_link(ei_node, ei_self(&globals.ei_cnode), from);
+			
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t remove_fetch_handlers(ei_node_t *ei_node, erlang_pid *from) {
+	remove_fetch_handler(ei_node, from, globals.config_fetch_binding);
+	remove_fetch_handler(ei_node, from, globals.directory_fetch_binding);
+	remove_fetch_handler(ei_node, from, globals.dialplan_fetch_binding);
+	remove_fetch_handler(ei_node, from, globals.chatplan_fetch_binding);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t fetch_reply(char *uuid_str, char *xml_str, switch_xml_binding_t *binding) {
+	ei_xml_agent_t *agent;
+	xml_fetch_reply_t *reply;
+	switch_status_t status = SWITCH_STATUS_NOTFOUND;
+	
+	agent = (ei_xml_agent_t *)switch_xml_get_binding_user_data(binding);
+
+    switch_mutex_lock(agent->replies_mutex);
+
+	reply = agent->replies;
+	while (reply != NULL) {
+		if (!strncmp(reply->uuid_str, uuid_str, SWITCH_UUID_FORMATTED_LENGTH)) {
+			if (!reply->xml_str) {
+				reply->xml_str = xml_str;
+				switch_thread_cond_broadcast(agent->new_reply);
+				status = SWITCH_STATUS_SUCCESS;
+			}
+			break;
+		}
+
+		reply = reply->next;
+	}
+    switch_mutex_unlock(agent->replies_mutex);
+
+	return status;
+}
+
+switch_status_t handle_api_command_streams(ei_node_t *ei_node, switch_stream_handle_t *stream) {
+	handle_api_command_stream(ei_node, stream, globals.config_fetch_binding);
+	handle_api_command_stream(ei_node, stream, globals.directory_fetch_binding);
+	handle_api_command_stream(ei_node, stream, globals.dialplan_fetch_binding);
+	handle_api_command_stream(ei_node, stream, globals.chatplan_fetch_binding);
+	
+	return SWITCH_STATUS_SUCCESS;
+}
+
+/* For Emacs:
+ * Local Variables:
+ * mode:c
+ * indent-tabs-mode:t
+ * tab-width:4
+ * c-basic-offset:4
+ * End:
+ * For VIM:
+ * vim:set softtabstop=4 shiftwidth=4 tabstop=4:
+ */
diff --git a/src/mod/event_handlers/mod_kazoo/kazoo_node.c b/src/mod/event_handlers/mod_kazoo/kazoo_node.c
new file mode 100644
index 0000000..4795242
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/kazoo_node.c
@@ -0,0 +1,1150 @@
+/*
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2012, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Andrew Thompson <andrew@hijacked.us>
+ * Rob Charlton <rob.charlton@savageminds.com>
+ * Darren Schreiber <d@d-man.org>
+ * Mike Jerris <mike@jerris.com>
+ * Tamas Cseke <tamas.cseke@virtual-call-center.eu>
+ *
+ *
+ * handle_msg.c -- handle messages received from erlang nodes
+ *
+ */
+#include "mod_kazoo.h"
+
+struct api_command_struct_s {
+	char *cmd;
+	char *arg;
+	ei_node_t *ei_node;
+	char uuid_str[SWITCH_UUID_FORMATTED_LENGTH + 1];
+	erlang_pid pid;
+	switch_memory_pool_t *pool;
+};
+typedef struct api_command_struct_s api_command_struct_t;
+
+static char *REQUEST_ATOMS[] = {
+	"noevents",
+	"exit",
+	"link",
+	"nixevent",
+	"sendevent",
+	"sendmsg",
+	"bind",
+	"getpid",
+	"version",
+	"bgapi",
+	"api",
+	"event",
+	"fetch_reply"
+};
+
+typedef enum {
+	REQUEST_NOEVENTS,
+	REQUEST_EXIT,
+	REQUEST_LINK,
+	REQUEST_NIXEVENT,
+	REQUEST_SENDEVENT,
+	REQUEST_SENDMSG,
+	REQUEST_BIND,
+	REQUEST_GETPID,
+	REQUEST_VERSION,
+	REQUEST_BGAPI,
+	REQUEST_API,
+	REQUEST_EVENT,
+	REQUEST_FETCH_REPLY,
+	REQUEST_MAX
+} request_atoms_t;
+
+static switch_status_t find_request(char *atom, int *request) {
+	for (int i = 0; i < REQUEST_MAX; i++) {
+		if(!strncmp(atom, REQUEST_ATOMS[i], MAXATOMLEN)) {
+			*request = i;
+			return SWITCH_STATUS_SUCCESS;
+		}
+	}
+
+	return SWITCH_STATUS_FALSE;
+}
+
+static void destroy_node_handler(ei_node_t *ei_node) {
+	int pending_api = 0;
+	void *pop;
+
+	switch_clear_flag(ei_node, LFLAG_RUNNING);
+
+	/* wait for pending bgapi requests to complete */
+	while ((pending_api = switch_atomic_read(&ei_node->pending_bgapi))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Waiting for %d pending bgapi requests to complete\n", pending_api);
+		switch_yield(500000);
+	}
+
+	switch_mutex_lock(ei_node->event_streams_mutex);	
+	remove_event_streams(&ei_node->event_streams);
+	switch_mutex_unlock(ei_node->event_streams_mutex);
+
+	remove_xml_clients(ei_node);
+
+	while (switch_queue_trypop(ei_node->asynchronous_msgs, &pop) == SWITCH_STATUS_SUCCESS) {
+		ei_asynchronous_msg_t *asynchronous_msg = (ei_asynchronous_msg_t *) pop;
+
+		ei_x_free(&asynchronous_msg->ebuf);
+		switch_safe_free(asynchronous_msg);
+	}
+
+	close_socketfd(&ei_node->nodefd);
+
+	switch_mutex_destroy(ei_node->event_streams_mutex);
+	
+	switch_core_destroy_memory_pool(&ei_node->pool);
+}
+
+static switch_status_t add_to_ei_nodes(ei_node_t *this_ei_node) {
+	switch_thread_rwlock_wrlock(globals.ei_nodes_lock);
+	
+	if (!globals.ei_nodes) {
+		globals.ei_nodes = this_ei_node;
+	} else {
+		this_ei_node->next = globals.ei_nodes;
+		globals.ei_nodes = this_ei_node;
+	}
+		
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+	
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t remove_from_ei_nodes(ei_node_t *this_ei_node) {
+	ei_node_t *ei_node, *prev = NULL;
+	int found = 0;
+
+	switch_thread_rwlock_wrlock(globals.ei_nodes_lock);
+
+	/* try to find the event bindings list for the requestor */
+	ei_node = globals.ei_nodes;
+	while(ei_node != NULL) {
+		if (ei_node == this_ei_node) {
+			found = 1;
+			break;
+		}
+
+		prev = ei_node;
+		ei_node = ei_node->next;
+	}
+
+	if (found) {
+		if (!prev) {
+			globals.ei_nodes = this_ei_node->next;
+		} else {
+			prev->next = ei_node->next;
+		}
+	}
+
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t api_exec(char *cmd, char *arg, char **reply) {
+	switch_stream_handle_t stream = { 0 };
+	switch_status_t status = SWITCH_STATUS_FALSE;
+
+	SWITCH_STANDARD_STREAM(stream);
+		
+	if (switch_api_execute(cmd, arg, NULL, &stream) != SWITCH_STATUS_SUCCESS) {
+		*reply = switch_mprintf("%s: Command not found", cmd);
+		status = SWITCH_STATUS_NOTFOUND;
+	} else if (!stream.data || !strlen(stream.data)) {
+		*reply = switch_mprintf("%s: Command returned no output", cmd);
+		status = SWITCH_STATUS_FALSE;
+	} else {
+		*reply = strdup(stream.data);
+		status = SWITCH_STATUS_SUCCESS;
+	}
+
+	/* if the reply starts with the char "-" (the start of -USAGE ...) */
+	/* the args were missing or incorrect */
+	if (**reply == '-') {
+		status = SWITCH_STATUS_FALSE;
+	}
+
+	switch_safe_free(stream.data);
+
+	return status;
+}
+
+static void *SWITCH_THREAD_FUNC bgapi_exec(switch_thread_t *thread, void *obj) {
+	api_command_struct_t *acs = (api_command_struct_t *) obj;
+	switch_memory_pool_t *pool = acs->pool;
+	char *reply = NULL;
+	char *cmd = acs->cmd;
+	char *arg = acs->arg;
+	ei_node_t *ei_node = acs->ei_node;
+	ei_asynchronous_msg_t *asynchronous_msg;
+
+	switch_malloc(asynchronous_msg, sizeof(*asynchronous_msg));
+	memcpy(&asynchronous_msg->pid, &acs->pid, sizeof(erlang_pid));
+
+	if(!switch_test_flag(ei_node, LFLAG_RUNNING) || !switch_test_flag(&globals, LFLAG_RUNNING)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Ignoring command while shuting down\n");
+		return NULL;
+	}
+
+	ei_x_new_with_version(&asynchronous_msg->ebuf);
+		
+	ei_x_encode_tuple_header(&asynchronous_msg->ebuf, 3);
+	
+	if (api_exec(cmd, arg, &reply) == SWITCH_STATUS_SUCCESS) {
+		ei_x_encode_atom(&asynchronous_msg->ebuf, "bgok");
+	} else {
+		ei_x_encode_atom(&asynchronous_msg->ebuf, "bgerror");
+	}
+
+	_ei_x_encode_string(&asynchronous_msg->ebuf, acs->uuid_str);
+	_ei_x_encode_string(&asynchronous_msg->ebuf, reply);
+
+	if (switch_queue_trypush(ei_node->asynchronous_msgs, asynchronous_msg) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Failed to send bgapi response %s to %s <%d.%d.%d>\n"
+						  ,acs->uuid_str
+						  ,acs->pid.node
+						  ,acs->pid.creation
+						  ,acs->pid.num
+						  ,acs->pid.serial);
+		ei_x_free(&asynchronous_msg->ebuf);
+		switch_safe_free(asynchronous_msg);	
+	}
+
+	switch_atomic_dec(&ei_node->pending_bgapi);
+	
+	switch_safe_free(reply);
+	switch_safe_free(acs->arg);
+	switch_core_destroy_memory_pool(&pool);
+
+	return NULL;
+}
+
+static void log_sendmsg_request(char *uuid, switch_event_t *event)
+{
+	char *cmd = switch_event_get_header(event, "call-command");
+	unsigned long cmd_hash;
+	switch_ssize_t hlen = -1;
+	unsigned long CMD_EXECUTE = switch_hashfunc_default("execute", &hlen);
+	unsigned long CMD_XFEREXT = switch_hashfunc_default("xferext", &hlen);
+//	unsigned long CMD_HANGUP = switch_hashfunc_default("hangup", &hlen);
+//	unsigned long CMD_NOMEDIA = switch_hashfunc_default("nomedia", &hlen);
+//	unsigned long CMD_UNICAST = switch_hashfunc_default("unicast", &hlen);
+
+	if (zstr(cmd)) {
+		return;
+	}
+
+	cmd_hash = switch_hashfunc_default(cmd, &hlen);
+	
+	if (cmd_hash == CMD_EXECUTE) {
+		char *app_name = switch_event_get_header(event, "execute-app-name");
+		char *app_arg = switch_event_get_header(event, "execute-app-arg");
+		
+		if(app_name) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "log|%s|executing %s %s \n", uuid, app_name, switch_str_nil(app_arg));
+		}
+	} else if (cmd_hash == CMD_XFEREXT) {
+		switch_event_header_t *hp;
+	
+		for (hp = event->headers; hp; hp = hp->next) {
+			char *app_name;
+			char *app_arg;
+			
+			if (!strcasecmp(hp->name, "application")) {
+				app_name = strdup(hp->value);
+				app_arg = strchr(app_name, ' ');
+			
+				if (app_arg) {
+					*app_arg++ = '\0';
+				}
+			
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "log|%s|building xferext extension: %s %s\n", uuid, app_name, app_arg);
+			}
+		}		
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "log|%s|transfered call to xferext extension\n", uuid);
+	}
+}
+
+static switch_status_t build_event(switch_event_t *event, ei_x_buff * buf) {
+	int propslist_length, arity;
+
+	if(!event) {
+		return SWITCH_STATUS_FALSE;
+	}
+
+	if (ei_decode_list_header(buf->buff, &buf->index, &propslist_length)) {
+		return SWITCH_STATUS_FALSE;
+	}
+
+	while (!ei_decode_tuple_header(buf->buff, &buf->index, &arity)) {
+		char key[1024];
+		char *value;
+
+		if (arity != 2) {
+			return SWITCH_STATUS_FALSE;
+		}
+
+		if (ei_decode_string_or_binary_limited(buf->buff, &buf->index, sizeof(key), key)) {
+			return SWITCH_STATUS_FALSE;
+		}
+
+		if (ei_decode_string_or_binary(buf->buff, &buf->index, &value)) {
+			return SWITCH_STATUS_FALSE;
+		}
+
+		if (!strcmp(key, "body")) {
+			switch_safe_free(event->body);
+			event->body = value;
+		} else	{
+			switch_event_add_header_string(event, SWITCH_STACK_BOTTOM | SWITCH_STACK_NODUP, key, value);
+		}
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t erlang_response_badarg(ei_x_buff * rbuf) {
+	if (rbuf) {
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "error");
+		ei_x_encode_atom(rbuf, "badarg");
+	}
+
+	return SWITCH_STATUS_GENERR;
+}
+
+static switch_status_t erlang_response_baduuid(ei_x_buff * rbuf) {
+	if (rbuf) {
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "error");
+		ei_x_encode_atom(rbuf, "baduuid");
+	}
+
+	return SWITCH_STATUS_NOTFOUND;
+}
+
+static switch_status_t erlang_response_notimplemented(ei_x_buff * rbuf) {
+	if (rbuf) {
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "error");
+		ei_x_encode_atom(rbuf, "not_implemented");
+	}
+
+	return SWITCH_STATUS_NOTFOUND;
+}
+
+static switch_status_t erlang_response_ok(ei_x_buff *rbuf) {
+	if (rbuf) {
+		ei_x_encode_atom(rbuf, "ok");
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_request_noevents(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	ei_event_stream_t *event_stream;
+
+	switch_mutex_lock(ei_node->event_streams_mutex);
+	if ((event_stream = find_event_stream(ei_node->event_streams, pid))) {
+		remove_event_bindings(event_stream);
+	}
+	switch_mutex_unlock(ei_node->event_streams_mutex);
+
+	return erlang_response_ok(rbuf);
+}
+
+static switch_status_t handle_request_exit(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	switch_clear_flag(ei_node, LFLAG_RUNNING);
+
+	return erlang_response_ok(rbuf);
+}
+
+static switch_status_t handle_request_link(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	ei_link(ei_node, ei_self(&globals.ei_cnode), pid);
+
+	return erlang_response_ok(rbuf);
+}
+
+static switch_status_t handle_request_nixevent(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	char event_name[MAXATOMLEN + 1];
+	switch_event_types_t event_type;
+	ei_event_stream_t *event_stream;
+	int custom = 0, length = 0;
+
+	if (ei_decode_list_header(buf->buff, &buf->index, &length)
+		|| length == 0) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch_mutex_lock(ei_node->event_streams_mutex);
+	if (!(event_stream = find_event_stream(ei_node->event_streams, pid))) {
+		switch_mutex_unlock(ei_node->event_streams_mutex);
+		return erlang_response_ok(rbuf);
+	}
+
+	for (int i = 1; i <= length; i++) {
+		if (ei_decode_atom_safe(buf->buff, &buf->index, event_name)) {
+			switch_mutex_unlock(ei_node->event_streams_mutex);
+			return erlang_response_badarg(rbuf);
+		}
+
+		if (custom) {
+			remove_event_binding(event_stream, SWITCH_EVENT_CUSTOM, event_name);
+		} else if (switch_name_event(event_name, &event_type) == SWITCH_STATUS_SUCCESS) {
+			switch (event_type) {
+			case SWITCH_EVENT_CUSTOM:
+				custom++;
+				break;
+			case SWITCH_EVENT_ALL:
+				for (switch_event_types_t type = 0; type < SWITCH_EVENT_ALL; type++) {
+					if(type != SWITCH_EVENT_CUSTOM) {
+						remove_event_binding(event_stream, type, NULL);
+					}
+				}
+				break;
+			default:
+				remove_event_binding(event_stream, event_type, NULL);
+			}
+		} else {
+			switch_mutex_unlock(ei_node->event_streams_mutex);
+			return erlang_response_badarg(rbuf);
+		}
+	}
+	switch_mutex_unlock(ei_node->event_streams_mutex);
+
+	return erlang_response_ok(rbuf);
+}
+
+static switch_status_t handle_request_sendevent(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	char event_name[MAXATOMLEN + 1];
+	char subclass_name[MAXATOMLEN + 1];
+	switch_event_types_t event_type;
+	switch_event_t *event = NULL;
+
+	if (ei_decode_atom_safe(buf->buff, &buf->index, event_name) 
+		|| switch_name_event(event_name, &event_type) != SWITCH_STATUS_SUCCESS) 
+	{
+		return erlang_response_badarg(rbuf);
+	}
+
+	if (!strncasecmp(event_name, "CUSTOM", MAXATOMLEN)) {
+		if(ei_decode_atom(buf->buff, &buf->index, subclass_name)) {
+			return erlang_response_badarg(rbuf);
+		}
+		switch_event_create_subclass(&event, event_type, subclass_name);
+	} else {
+		switch_event_create(&event, event_type);
+	}
+
+	if (build_event(event, buf) == SWITCH_STATUS_SUCCESS) {
+		switch_event_fire(&event);
+		return erlang_response_ok(rbuf);
+	} 
+	
+	if(event) {
+		switch_event_destroy(&event);
+	}
+
+	return erlang_response_badarg(rbuf);
+}
+
+static switch_status_t handle_request_sendmsg(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	switch_core_session_t *session;
+	switch_event_t *event = NULL;
+	char uuid_str[SWITCH_UUID_FORMATTED_LENGTH + 1];
+
+	if (ei_decode_string_or_binary_limited(buf->buff, &buf->index, sizeof(uuid_str), uuid_str)) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch_event_create(&event, SWITCH_EVENT_SEND_MESSAGE);
+	if (build_event(event, buf) != SWITCH_STATUS_SUCCESS) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	log_sendmsg_request(uuid_str, event);
+
+	if (zstr_buf(uuid_str) || !(session = switch_core_session_locate(uuid_str))) {
+		return erlang_response_badarg(rbuf);
+	}
+	switch_core_session_queue_private_event(session, &event, SWITCH_FALSE);
+	switch_core_session_rwunlock(session);
+
+	return erlang_response_ok(rbuf);
+}
+
+static switch_status_t handle_request_bind(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	char section_str[MAXATOMLEN + 1];
+	switch_xml_section_t section;
+
+	if (ei_decode_atom_safe(buf->buff, &buf->index, section_str) 
+		|| !(section = switch_xml_parse_section_string(section_str))) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch(section) {
+	case SWITCH_XML_SECTION_CONFIG:
+		add_fetch_handler(ei_node, pid, globals.config_fetch_binding);
+		break;
+	case SWITCH_XML_SECTION_DIRECTORY:
+		add_fetch_handler(ei_node, pid, globals.directory_fetch_binding);
+		break;
+	case SWITCH_XML_SECTION_DIALPLAN:
+		add_fetch_handler(ei_node, pid, globals.dialplan_fetch_binding);
+		break;
+	case SWITCH_XML_SECTION_CHATPLAN:
+		add_fetch_handler(ei_node, pid, globals.chatplan_fetch_binding);
+		break;
+	default:
+		return erlang_response_badarg(rbuf);
+	}
+	
+	return erlang_response_ok(rbuf);
+}
+
+static switch_status_t handle_request_getpid(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	if (rbuf) {
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "ok");
+		ei_x_encode_pid(rbuf, ei_self(&globals.ei_cnode));
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_request_version(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	if (rbuf) {
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "ok");
+		_ei_x_encode_string(rbuf, VERSION);
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_request_bgapi(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	api_command_struct_t *acs = NULL;
+	switch_memory_pool_t *pool;
+	switch_thread_t *thread;
+	switch_threadattr_t *thd_attr = NULL;
+	switch_uuid_t uuid;
+	char cmd[MAXATOMLEN + 1];
+
+	if (ei_decode_atom_safe(buf->buff, &buf->index, cmd)) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch_core_new_memory_pool(&pool);
+	acs = switch_core_alloc(pool, sizeof(*acs));
+
+	if (ei_decode_string_or_binary(buf->buff, &buf->index, &acs->arg)) {
+		switch_core_destroy_memory_pool(&pool);
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO, "bgexec: %s(%s)\n", cmd, acs->arg);
+	
+	acs->pool = pool;
+	acs->ei_node = ei_node;
+	acs->cmd = switch_core_strdup(pool, cmd);
+	memcpy(&acs->pid, pid, sizeof(erlang_pid));
+
+	switch_threadattr_create(&thd_attr, acs->pool);
+	switch_threadattr_detach_set(thd_attr, 1);
+	switch_threadattr_stacksize_set(thd_attr, SWITCH_THREAD_STACKSIZE);
+	
+	switch_uuid_get(&uuid);
+	switch_uuid_format(acs->uuid_str, &uuid);
+	switch_thread_create(&thread, thd_attr, bgapi_exec, acs, acs->pool);
+
+	switch_atomic_inc(&ei_node->pending_bgapi);
+
+	if (rbuf) {
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "ok");
+		_ei_x_encode_string(rbuf, acs->uuid_str);
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_request_api(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	char cmd[MAXATOMLEN + 1];
+	char *arg;
+
+	if (ei_decode_atom_safe(buf->buff, &buf->index, cmd)) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	if (ei_decode_string_or_binary(buf->buff, &buf->index, &arg)) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO, "exec: %s(%s)\n", cmd, arg);
+
+	if (rbuf) {
+		char *reply;
+
+		ei_x_encode_tuple_header(rbuf, 2);
+	
+		if (api_exec(cmd, arg, &reply) == SWITCH_STATUS_SUCCESS) {
+			ei_x_encode_atom(rbuf, "ok");
+		} else {
+			ei_x_encode_atom(rbuf, "error");
+		}
+
+		_ei_x_encode_string(rbuf, reply);
+		switch_safe_free(reply);
+	}
+
+	switch_safe_free(arg);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_request_event(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	char event_name[MAXATOMLEN + 1];
+	switch_event_types_t event_type;
+	ei_event_stream_t *event_stream;
+	int custom = 0, length = 0;
+
+	if (ei_decode_list_header(buf->buff, &buf->index, &length) || !length) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch_mutex_lock(ei_node->event_streams_mutex);
+	if (!(event_stream = find_event_stream(ei_node->event_streams, pid))) {
+		event_stream = new_event_stream(&ei_node->event_streams, pid);
+		/* ensure we are notified if the requesting processes dies so we can clean up */
+		ei_link(ei_node, ei_self(&globals.ei_cnode), pid);
+	}
+
+	for (int i = 1; i <= length; i++) {
+		if (ei_decode_atom_safe(buf->buff, &buf->index, event_name)) {
+			switch_mutex_unlock(ei_node->event_streams_mutex);
+			return erlang_response_badarg(rbuf);
+		}
+
+		if (custom) {
+			add_event_binding(event_stream, SWITCH_EVENT_CUSTOM, event_name);
+		} else if (switch_name_event(event_name, &event_type) == SWITCH_STATUS_SUCCESS) {
+			switch (event_type) {
+			case SWITCH_EVENT_CUSTOM:
+				custom++;
+				break;
+			case SWITCH_EVENT_ALL:
+				for (switch_event_types_t type = 0; type < SWITCH_EVENT_ALL; type++) {
+					if(type != SWITCH_EVENT_CUSTOM) {
+						add_event_binding(event_stream, type, NULL);
+					}
+				}
+				break;
+			default:
+				add_event_binding(event_stream, event_type, NULL);
+			}
+		} else {
+			switch_mutex_unlock(ei_node->event_streams_mutex);
+			return erlang_response_badarg(rbuf);
+		}
+	}
+	switch_mutex_unlock(ei_node->event_streams_mutex);
+
+	if (rbuf) {
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "ok");
+		ei_x_encode_tuple_header(rbuf, 2);
+		ei_x_encode_atom(rbuf, "port");
+		ei_x_encode_ulong(rbuf, get_stream_port(event_stream));
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_request_fetch_reply(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	char section_str[MAXATOMLEN + 1];
+	char uuid_str[SWITCH_UUID_FORMATTED_LENGTH + 1];
+	char *xml_str;
+	switch_xml_section_t section;
+	switch_status_t result;
+
+	if (ei_decode_atom_safe(buf->buff, &buf->index, section_str) 
+		|| !(section = switch_xml_parse_section_string(section_str))) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	if (ei_decode_string_or_binary_limited(buf->buff, &buf->index, sizeof(uuid_str), uuid_str)
+		|| zstr_buf(uuid_str)) {
+		return erlang_response_badarg(rbuf);
+	}
+
+	if (ei_decode_string_or_binary(buf->buff, &buf->index, &xml_str)) {
+		return erlang_response_badarg(rbuf);
+	}
+	
+	if (zstr(xml_str)) {
+		switch_safe_free(xml_str);
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch(section) {
+	case SWITCH_XML_SECTION_CONFIG:
+		result = fetch_reply(uuid_str, xml_str, globals.config_fetch_binding);
+		break;
+	case SWITCH_XML_SECTION_DIRECTORY:
+		result = fetch_reply(uuid_str, xml_str, globals.directory_fetch_binding);
+		break;
+	case SWITCH_XML_SECTION_DIALPLAN:
+		result = fetch_reply(uuid_str, xml_str, globals.dialplan_fetch_binding);
+		break;
+	case SWITCH_XML_SECTION_CHATPLAN:
+		result = fetch_reply(uuid_str, xml_str, globals.chatplan_fetch_binding);
+		break;
+	default:
+		return erlang_response_badarg(rbuf);
+	}
+
+	if (result == SWITCH_STATUS_SUCCESS) {
+		return erlang_response_ok(rbuf);
+	} else {
+		return erlang_response_baduuid(rbuf);
+	}
+}
+
+static switch_status_t handle_kazoo_request(ei_node_t *ei_node, erlang_pid *pid, ei_x_buff *buf, ei_x_buff *rbuf) {
+	char atom[MAXATOMLEN + 1];
+	int type, size, arity = 0, request;
+
+	/* ...{_, _}} | ...atom()} = Buf */
+	ei_get_type(buf->buff, &buf->index, &type, &size);
+
+	/* is_tuple(Type) */
+	if (type == ERL_SMALL_TUPLE_EXT) {
+		/* ..._, _} = Buf */
+		ei_decode_tuple_header(buf->buff, &buf->index, &arity);
+	}
+
+	if (ei_decode_atom_safe(buf->buff, &buf->index, atom)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Recieved mod_kazoo message that did not contain a command (ensure you are using Kazoo v2.14+).\n");
+		return erlang_response_badarg(rbuf);
+	}
+
+	if (find_request(atom, &request) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Recieved mod_kazoo message for unimplemented feature (ensure you are using Kazoo v2.14+): %s\n", atom);
+		return erlang_response_badarg(rbuf);
+	}
+
+	switch(request) {
+	case REQUEST_NOEVENTS:
+		return handle_request_noevents(ei_node, pid, buf, rbuf);
+	case REQUEST_EXIT:
+		return handle_request_exit(ei_node, pid, buf, rbuf);
+	case REQUEST_LINK:
+		return handle_request_link(ei_node, pid, buf, rbuf);
+	case REQUEST_NIXEVENT:
+		return handle_request_nixevent(ei_node, pid, buf, rbuf);
+	case REQUEST_SENDEVENT:
+		return handle_request_sendevent(ei_node, pid, buf, rbuf);
+	case REQUEST_SENDMSG:
+		return handle_request_sendmsg(ei_node, pid, buf, rbuf);
+	case REQUEST_BIND:
+		return handle_request_bind(ei_node, pid, buf, rbuf);
+	case REQUEST_GETPID:
+		return handle_request_getpid(ei_node, pid, buf, rbuf);
+	case REQUEST_VERSION:
+		return handle_request_version(ei_node, pid, buf, rbuf);
+	case REQUEST_BGAPI:
+		return handle_request_bgapi(ei_node, pid, buf, rbuf);
+	case REQUEST_API:
+		return handle_request_api(ei_node, pid, buf, rbuf);
+	case REQUEST_EVENT:
+		return handle_request_event(ei_node, pid, buf, rbuf);
+	case REQUEST_FETCH_REPLY:
+		return handle_request_fetch_reply(ei_node, pid, buf, rbuf);
+	default:
+		return erlang_response_notimplemented(rbuf);
+	}	
+}
+
+static switch_status_t handle_mod_kazoo_request(ei_node_t *ei_node, erlang_msg *msg, ei_x_buff *buf) {
+	char atom[MAXATOMLEN + 1];
+	int version, type, size, arity;
+
+	buf->index = 0;
+	ei_decode_version(buf->buff, &buf->index, &version);
+	ei_get_type(buf->buff, &buf->index, &type, &size);
+
+	/* is_tuple(Type) */
+	if (type != ERL_SMALL_TUPLE_EXT) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Received erlang message of an unexpected type (ensure you are using Kazoo v2.14+).\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	ei_decode_tuple_header(buf->buff, &buf->index, &arity);
+
+	if (ei_decode_atom_safe(buf->buff, &buf->index, atom)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Recieved erlang message tuple that did not start with an atom (ensure you are using Kazoo v2.14+).\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	/* {'$gen_cast', {_, _}} = Buf */
+	if (arity == 2 && !strncmp(atom, "$gen_cast", 9)) {
+		return handle_kazoo_request(ei_node, &msg->from, buf, NULL);
+	/* {'$gen_call', {_, _}, {_, _}} = Buf */
+	} else if (arity == 3 && !strncmp(atom, "$gen_call", 9)) {
+		switch_status_t status;
+		ei_x_buff rbuf;
+		erlang_pid pid;
+		erlang_ref ref;
+
+		ei_x_new_with_version(&rbuf);
+
+		/* ...{_, _}, {_, _}} = Buf */
+		ei_get_type(buf->buff, &buf->index, &type, &size);
+
+		/* is_tuple(Type) */
+		if (type != ERL_SMALL_TUPLE_EXT) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Received erlang call message of an unexpected type (ensure you are using Kazoo v2.14+).\n");
+			return SWITCH_STATUS_GENERR;
+		}
+
+		/* ..._, _}, {_, _}} = Buf */
+		ei_decode_tuple_header(buf->buff, &buf->index, &arity);
+		
+		/* ...pid(), _}, {_, _}} = Buf */
+		if (ei_decode_pid(buf->buff, &buf->index, &pid)) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Received erlang call without a reply pid (ensure you are using Kazoo v2.14+).\n");
+			return SWITCH_STATUS_GENERR;
+		}
+
+		/* ...ref()}, {_, _}} = Buf */
+		if (ei_decode_ref(buf->buff, &buf->index, &ref)) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Received erlang call without a reply tag (ensure you are using Kazoo v2.14+).\n");
+			return SWITCH_STATUS_GENERR;
+		}
+
+		/* rbuf = {ref(), ... */
+		ei_x_encode_tuple_header(&rbuf, 2);
+		ei_x_encode_ref(&rbuf, &ref);
+
+		status = handle_kazoo_request(ei_node, &msg->from, buf, &rbuf);
+
+		ei_helper_send(ei_node, &pid, &rbuf);
+
+		ei_x_free(&rbuf);
+		
+		return status;
+	} else {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Recieved inappropriate erlang message (ensure you are using Kazoo v2.14+)\n");
+		return SWITCH_STATUS_GENERR;
+	}
+}
+
+/* fake enough of the net_kernel module to be able to respond to net_adm:ping */
+static switch_status_t handle_net_kernel_request(ei_node_t *ei_node, erlang_msg *msg, ei_x_buff *buf) {
+	int version, size, type, arity;
+	char atom[MAXATOMLEN + 1];
+	ei_x_buff rbuf;
+	erlang_ref ref;
+	erlang_pid pid;
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Received net_kernel message, attempting to reply\n");
+
+	buf->index = 0;
+	ei_decode_version(buf->buff, &buf->index, &version);
+	ei_get_type(buf->buff, &buf->index, &type, &size);
+
+	/* is_tuple(Buff) */
+	if (type != ERL_SMALL_TUPLE_EXT) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Received net_kernel message of an unexpected type\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	ei_decode_tuple_header(buf->buff, &buf->index, &arity);
+
+	/* {_, _, _} = Buf */
+	if (arity != 3) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Received net_kernel tuple has an unexpected arity\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	/* {'$gen_call', _, _} = Buf */
+	if (ei_decode_atom_safe(buf->buff, &buf->index, atom) || strncmp(atom, "$gen_call", 9)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Received net_kernel message tuple does not begin with the atom '$gen_call'\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	ei_get_type(buf->buff, &buf->index, &type, &size);
+
+	/* {_, Sender, _}=Buff, is_tuple(Sender) */
+	if (type != ERL_SMALL_TUPLE_EXT) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Second element of the net_kernel tuple is an unexpected type\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	ei_decode_tuple_header(buf->buff, &buf->index, &arity);
+
+	/* {_, _}=Sender */
+	if (arity != 2) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Second element of the net_kernel message has an unexpected arity\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	/* {Pid, Ref}=Sender */
+	if (ei_decode_pid(buf->buff, &buf->index, &pid) || ei_decode_ref(buf->buff, &buf->index, &ref)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Unable to decode erlang pid or ref of the net_kernel tuple second element\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	ei_get_type(buf->buff, &buf->index, &type, &size);
+
+	/* {_, _, Request}=Buff, is_tuple(Request) */
+	if (type != ERL_SMALL_TUPLE_EXT) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Third element of the net_kernel message is an unexpected type\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	ei_decode_tuple_header(buf->buff, &buf->index, &arity);
+
+	/* {_, _}=Request */
+	if (arity != 2) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Third element of the net_kernel message has an unexpected arity\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	/* {is_auth, _}=Request */
+	if (ei_decode_atom_safe(buf->buff, &buf->index, atom) || strncmp(atom, "is_auth", MAXATOMLEN)) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "The net_kernel message third element does not begin with the atom 'is_auth'\n");
+		return SWITCH_STATUS_GENERR;
+	}
+
+	/* To ! {Tag, Reply} */
+	ei_x_new_with_version(&rbuf);
+	ei_x_encode_tuple_header(&rbuf, 2);
+	ei_x_encode_ref(&rbuf, &ref);
+	ei_x_encode_atom(&rbuf, "yes");
+
+	ei_helper_send(ei_node, &pid, &rbuf);
+
+	ei_x_free(&rbuf);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_erl_send(ei_node_t *ei_node, erlang_msg *msg, ei_x_buff *buf) {
+	if (!strncmp(msg->toname, "net_kernel", MAXATOMLEN)) {
+		return handle_net_kernel_request(ei_node, msg, buf);
+	} else if (!strncmp(msg->toname, "mod_kazoo", MAXATOMLEN)) {
+		return handle_mod_kazoo_request(ei_node, msg, buf);
+	} else {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Recieved erlang message to unknown process \"%s\" (ensure you are using Kazoo v2.14+).\n", msg->toname);
+		return SWITCH_STATUS_GENERR;
+	}
+}
+
+static switch_status_t handle_erl_msg(ei_node_t *ei_node, erlang_msg *msg, ei_x_buff *buf) {
+	switch (msg->msgtype) {
+	case ERL_SEND:
+	case ERL_REG_SEND:
+		return handle_erl_send(ei_node, msg, buf);
+	case ERL_LINK:
+		/* we received an erlang link request?	Should we be linking or are they linking to us and this just informs us? */
+		return SWITCH_STATUS_SUCCESS;
+	case ERL_UNLINK:
+		/* we received an erlang unlink request?  Same question as the ERL_LINK, are we expected to do something? */
+		return SWITCH_STATUS_SUCCESS;
+	case ERL_EXIT:
+		/* we received a notice that a process we were linked to has exited, clean up any bindings */
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Received erlang exit notice for %s <%d.%d.%d>\n", msg->from.node, msg->from.creation, msg->from.num, msg->from.serial);
+
+		switch_mutex_lock(ei_node->event_streams_mutex);
+		remove_event_stream(&ei_node->event_streams, &msg->from);
+		switch_mutex_unlock(ei_node->event_streams_mutex);
+
+		remove_fetch_handlers(ei_node, &msg->from);
+		return SWITCH_STATUS_SUCCESS;
+	case ERL_EXIT2:
+		/* erlang nodes appear to send both the old and new style exit notices so just ignore these */
+		return SWITCH_STATUS_FALSE;
+	default:
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "Received unexpected erlang message type %d\n", (int) (msg->msgtype));
+		return SWITCH_STATUS_FALSE;
+	}
+}
+
+static void *SWITCH_THREAD_FUNC handle_requests(switch_thread_t *thread, void *obj) {
+	ei_node_t *ei_node = (ei_node_t *) obj;
+
+	switch_atomic_inc(&globals.threads);
+  
+	switch_assert(ei_node != NULL);
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Starting erlang request handler %p: %s (%s:%d)\n", (void *)ei_node, ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port);
+
+	add_to_ei_nodes(ei_node);
+
+	while (switch_test_flag(ei_node, LFLAG_RUNNING) && switch_test_flag(&globals, LFLAG_RUNNING)) {
+		erlang_msg msg;
+		ei_x_buff buf;
+		int status;
+		void *pop;
+
+		if (switch_queue_trypop(ei_node->asynchronous_msgs, &pop) == SWITCH_STATUS_SUCCESS) {
+			ei_asynchronous_msg_t *asynchronous_msg = (ei_asynchronous_msg_t *) pop;
+			ei_helper_send(ei_node, &asynchronous_msg->pid, &asynchronous_msg->ebuf);
+			ei_x_free(&asynchronous_msg->ebuf);
+			switch_safe_free(asynchronous_msg);
+		}
+
+		/* create a new buf for the erlang message and a rbuf for the reply */
+		ei_x_new(&buf);
+
+		/* wait for a erlang message, or timeout to check if the module is still running */
+		status = ei_xreceive_msg_tmo(ei_node->nodefd, &msg, &buf, 5);
+
+		switch (status) {
+		case ERL_TICK:
+			/* erlang nodes send ticks to eachother to validate they are still reachable, we dont have to do anything here */
+			break;
+		case ERL_MSG:
+			handle_erl_msg(ei_node, &msg, &buf);
+			break;
+		case ERL_ERROR:
+			switch (erl_errno) {
+			case ETIMEDOUT:
+			case EAGAIN:
+				/* if ei_xreceive_msg_tmo just timed out, ignore it and let the while loop check if we are still running */
+				/* the erlang lib just wants us to try to receive again, so we will! */
+				break;
+			case EMSGSIZE:
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Erlang communication fault with node %p %s (%s:%d): my spoon is too big\n", (void *)ei_node, ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port);
+				switch_clear_flag(ei_node, LFLAG_RUNNING);
+				break;
+			case EIO:
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_NOTICE, "Erlang communication fault with node %p %s (%s:%d): socket closed or I/O error\n", (void *)ei_node, ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port);
+				switch_clear_flag(ei_node, LFLAG_RUNNING);
+				break;
+			default:
+				/* OH NOS! something has gone horribly wrong, shutdown the connection if status set by ei_xreceive_msg_tmo is less than or equal to 0 */
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Erlang communication fault with node %p %s (%s:%d): erl_errno=%d errno=%d\n", (void *)ei_node, ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port, erl_errno, errno);
+				if (status < 0) {
+					switch_clear_flag(ei_node, LFLAG_RUNNING);
+				}
+				break;
+			}
+			break;
+		default:
+			/* HUH? didnt plan for this, whatevs shutdown the connection if status set by ei_xreceive_msg_tmo is less than or equal to 0 */
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unexpected erlang receive status %p %s (%s:%d): %d\n", (void *)ei_node, ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port, status);
+			if (status < 0) {
+				switch_clear_flag(ei_node, LFLAG_RUNNING);
+			}
+			break;
+		}
+		ei_x_free(&buf);
+	}
+
+	remove_from_ei_nodes(ei_node);
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Shutdown erlang request handler %p: %s (%s:%d)\n", (void *)ei_node, ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port);
+
+	destroy_node_handler(ei_node);
+
+	switch_atomic_dec(&globals.threads);
+	return NULL;
+}
+
+/* Create a thread to wait for messages from an erlang node and process them */
+switch_status_t new_kazoo_node(int nodefd, ErlConnect *conn) {
+	switch_thread_t *thread;
+	switch_threadattr_t *thd_attr = NULL;
+	switch_memory_pool_t *pool = NULL;
+	switch_sockaddr_t *sa;
+	ei_node_t *ei_node;
+    char remotebuf[25], localbuf[25];
+
+	/* create memory pool for this erlang node */
+	if (switch_core_new_memory_pool(&pool) != SWITCH_STATUS_SUCCESS) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Out of memory: Too bad drinking scotch isn't a paying job or Kenny's dad would be a millionare!\n");
+		return SWITCH_STATUS_MEMERR;
+	}
+	
+	/* from the erlang node's memory pool, allocate some memory for the structure */
+	if (!(ei_node = switch_core_alloc(pool, sizeof (*ei_node)))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Out of memory: Stan, don't you know the first law of physics? Anything that's fun costs at least eight dollars.\n");
+		return SWITCH_STATUS_MEMERR;
+	}
+
+	memset(ei_node, 0, sizeof(*ei_node));
+
+	/* store the location of our pool */
+	ei_node->pool = pool;
+	
+	/* save the file descriptor that the erlang interface lib uses to communicate with the new node */
+	ei_node->nodefd = nodefd;
+	ei_node->peer_nodename = switch_core_strdup(ei_node->pool, conn->nodename);
+	ei_node->created_time = switch_micro_time_now();
+
+	/* store the IP and node name we are talking with */
+	switch_os_sock_put(&ei_node->socket, (switch_os_socket_t *)&nodefd, pool);
+
+	switch_socket_addr_get(&sa, SWITCH_FALSE, ei_node->socket);
+	ei_node->remote_port = switch_sockaddr_get_port(sa);
+    ei_node->remote_ip = switch_get_addr(remotebuf, sizeof (remotebuf), sa);
+
+	switch_socket_addr_get(&sa, SWITCH_TRUE, ei_node->socket);
+	ei_node->local_port = switch_sockaddr_get_port(sa);
+    ei_node->local_ip = switch_get_addr(localbuf, sizeof (localbuf), sa);
+
+	switch_queue_create(&ei_node->asynchronous_msgs, MAX_QUEUE_LEN, pool);
+	switch_mutex_init(&ei_node->event_streams_mutex, SWITCH_MUTEX_DEFAULT, pool);
+
+	/* when we start we are running */
+	switch_set_flag(ei_node, LFLAG_RUNNING);
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO, "New erlang connection from node %s (%s:%d)\n", ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port);
+
+	switch_threadattr_create(&thd_attr, ei_node->pool);
+	switch_threadattr_detach_set(thd_attr, 1);
+	switch_threadattr_stacksize_set(thd_attr, SWITCH_THREAD_STACKSIZE);
+	switch_thread_create(&thread, thd_attr, handle_requests, ei_node, ei_node->pool);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+/* For Emacs:
+ * Local Variables:
+ * mode:c
+ * indent-tabs-mode:t
+ * tab-width:4
+ * c-basic-offset:4
+ * End:
+ * For VIM:
+ * vim:set softtabstop=4 shiftwidth=4 tabstop=4:
+ */
diff --git a/src/mod/event_handlers/mod_kazoo/kazoo_utils.c b/src/mod/event_handlers/mod_kazoo/kazoo_utils.c
new file mode 100644
index 0000000..0f82393
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/kazoo_utils.c
@@ -0,0 +1,512 @@
+/*
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2012, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Andrew Thompson <andrew@hijacked.us>
+ * Rob Charlton <rob.charlton@savageminds.com>
+ * Karl Anderson <karl@2600hz.com>
+ *
+ * Original from mod_erlang_event.
+ * ei_helpers.c -- helper functions for ei
+ *
+ */
+#include <switch.h>
+#include <ei.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+#include <resolv.h>
+#include "mod_kazoo.h"
+
+/* Stolen from code added to ei in R12B-5.
+ * Since not everyone has this version yet;
+ * provide our own version.
+ * */
+
+#define put8(s,n) do { \
+	(s)[0] = (char)((n) & 0xff); \
+	(s) += 1; \
+} while (0)
+
+#define put32be(s,n) do {  \
+	(s)[0] = ((n) >>  24) & 0xff; \
+	(s)[1] = ((n) >>  16) & 0xff; \
+	(s)[2] = ((n) >>  8) & 0xff;  \
+	(s)[3] = (n) & 0xff; \
+	(s) += 4; \
+} while (0)
+
+#ifdef EI_DEBUG
+static void ei_x_print_reg_msg(ei_x_buff *buf, char *dest, int send) {
+    char *mbuf = NULL;
+    int i = 1;
+	
+    ei_s_print_term(&mbuf, buf->buff, &i);
+	
+    if (send) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Encoded term %s to '%s'\n", mbuf, dest);
+    } else {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Decoded term %s for '%s'\n", mbuf, dest);
+    }
+	
+    free(mbuf);
+}
+
+static void ei_x_print_msg(ei_x_buff *buf, erlang_pid *pid, int send) {
+    char *pbuf = NULL;
+    int i = 0;
+    ei_x_buff pidbuf;
+
+    ei_x_new(&pidbuf);
+    ei_x_encode_pid(&pidbuf, pid);
+
+    ei_s_print_term(&pbuf, pidbuf.buff, &i);
+
+    ei_x_print_reg_msg(buf, pbuf, send);
+    free(pbuf);
+}
+#endif
+
+void ei_encode_switch_event_headers(ei_x_buff *ebuf, switch_event_t *event) {
+    switch_event_header_t *hp;
+    char *uuid = switch_event_get_header(event, "unique-id");
+    int i;
+
+    for (i = 0, hp = event->headers; hp; hp = hp->next, i++);
+
+    if (event->body)
+        i++;
+
+    ei_x_encode_list_header(ebuf, i + 1);
+
+    if (uuid) {
+		char *unique_id = switch_event_get_header(event, "unique-id");
+		ei_x_encode_binary(ebuf, unique_id, strlen(unique_id));
+    } else {
+        ei_x_encode_atom(ebuf, "undefined");
+    }
+
+    for (hp = event->headers; hp; hp = hp->next) {
+        ei_x_encode_tuple_header(ebuf, 2);
+        ei_x_encode_binary(ebuf, hp->name, strlen(hp->name));
+        switch_url_decode(hp->value);
+        ei_x_encode_binary(ebuf, hp->value, strlen(hp->value));
+    }
+
+    if (event->body) {
+        ei_x_encode_tuple_header(ebuf, 2);
+        ei_x_encode_binary(ebuf, "body", strlen("body"));
+        ei_x_encode_binary(ebuf, event->body, strlen(event->body));
+    }
+
+    ei_x_encode_empty_list(ebuf);
+}
+
+void close_socket(switch_socket_t ** sock) {
+	if (*sock) {
+		switch_socket_shutdown(*sock, SWITCH_SHUTDOWN_READWRITE);
+		switch_socket_close(*sock);
+		*sock = NULL;
+	}
+}
+
+void close_socketfd(int *sockfd) {
+	if (*sockfd) {
+		shutdown(*sockfd, SHUT_RDWR);
+        close(*sockfd);
+    }
+}
+
+switch_socket_t *create_socket(switch_memory_pool_t *pool) {
+	switch_sockaddr_t *sa;
+	switch_socket_t *socket;
+
+	if(switch_sockaddr_info_get(&sa, globals.ip, SWITCH_UNSPEC, 0, 0, pool)) {
+		return NULL;
+	}
+
+	if (switch_socket_create(&socket, switch_sockaddr_get_family(sa), SOCK_STREAM, SWITCH_PROTO_TCP, pool)) {
+		return NULL;
+	}
+
+	if (switch_socket_opt_set(socket, SWITCH_SO_REUSEADDR, 1)) {
+		return NULL;
+	}
+
+	if (switch_socket_bind(socket, sa)) {
+		return NULL;
+	}
+
+	if (switch_socket_listen(socket, 5)){
+		return NULL;
+	}
+
+	//	if (globals.nat_map && switch_nat_get_type()) {
+	//		switch_nat_add_mapping(port, SWITCH_NAT_TCP, NULL, SWITCH_FALSE);
+	//	}
+	
+	return socket;
+}
+
+switch_status_t create_ei_cnode(const char *ip_addr, const char *name, struct ei_cnode_s *ei_cnode) {
+    struct hostent *nodehost;
+    char hostname[EI_MAXHOSTNAMELEN + 1] = "";
+    char nodename[MAXNODELEN + 1];
+    char cnodename[EI_MAXALIVELEN + 1];
+    //EI_MAX_COOKIE_SIZE+1
+    char *atsign;
+		
+    /* copy the erlang interface nodename into something we can modify */
+    strncpy(cnodename, name, EI_MAXALIVELEN);
+
+    if ((atsign = strchr(cnodename, '@'))) {
+        /* we got a qualified node name, don't guess the host/domain */
+        snprintf(nodename, MAXNODELEN + 1, "%s", globals.ei_nodename);
+        /* truncate the alivename at the @ */
+        *atsign = '\0';
+    } else {
+        if ((nodehost = gethostbyaddr(ip_addr, sizeof (ip_addr), AF_INET))) {
+            memcpy(hostname, nodehost->h_name, EI_MAXHOSTNAMELEN);
+        }
+
+        if (zstr_buf(hostname) || !strncasecmp(globals.ip, "0.0.0.0", 7)) {
+            gethostname(hostname, EI_MAXHOSTNAMELEN);
+        }
+
+/*		else {
+            if (!(_res.options & RES_INIT)) {
+                // init the resolver
+                res_init();
+            }
+            if (_res.dnsrch[0] && !zstr_buf(_res.dnsrch[0])) {
+                strncat(hostname, ".", 1);
+                strncat(hostname, _res.dnsrch[0], EI_MAXHOSTNAMELEN - strlen(hostname));
+            }
+}
+*/
+        snprintf(nodename, MAXNODELEN + 1, "%s@%s", globals.ei_nodename, hostname);
+    }
+
+	if (globals.ei_shortname) {
+		char *off;
+		if ((off = strchr(nodename, '.'))) {
+			*off = '\0';
+		}
+	} 
+
+    /* init the ec stuff */
+    if (ei_connect_xinit(ei_cnode, hostname, cnodename, nodename, (Erl_IpAddr) ip_addr, globals.ei_cookie, 0) < 0) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Failed to initialize the erlang interface connection structure\n");
+        return SWITCH_STATUS_FALSE;
+    }
+
+    return SWITCH_STATUS_SUCCESS;
+}
+
+switch_status_t ei_compare_pids(const erlang_pid *pid1, const erlang_pid *pid2) {
+    if ((!strcmp(pid1->node, pid2->node)) 
+		&& pid1->creation == pid2->creation 
+		&& pid1->num == pid2->num 
+		&& pid1->serial == pid2->serial) {
+        return SWITCH_STATUS_SUCCESS;
+    } else {
+        return SWITCH_STATUS_FALSE;
+    }
+}
+
+void ei_link(ei_node_t *ei_node, erlang_pid * from, erlang_pid * to) {
+    char msgbuf[2048];
+    char *s;
+    int index = 0;
+
+    index = 5; /* max sizes: */
+    ei_encode_version(msgbuf, &index); /*   1 */
+    ei_encode_tuple_header(msgbuf, &index, 3);
+    ei_encode_long(msgbuf, &index, ERL_LINK);
+    ei_encode_pid(msgbuf, &index, from); /* 268 */
+    ei_encode_pid(msgbuf, &index, to); /* 268 */
+
+    /* 5 byte header missing */
+    s = msgbuf;
+    put32be(s, index - 4); /*   4 */
+    put8(s, ERL_PASS_THROUGH); /*   1 */
+    /* sum:  542 */
+
+    if (write(ei_node->nodefd, msgbuf, index) == -1) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Failed to link to process on %s\n", ei_node->peer_nodename);
+    }
+}
+
+void ei_encode_switch_event(ei_x_buff *ebuf, switch_event_t *event) {
+    ei_x_encode_tuple_header(ebuf, 2);
+    ei_x_encode_atom(ebuf, "event");
+    ei_encode_switch_event_headers(ebuf, event);
+}
+
+int ei_helper_send(ei_node_t *ei_node, erlang_pid *to, ei_x_buff *buf) {
+    int ret = 0;
+
+    if (ei_node->nodefd) {
+#ifdef EI_DEBUG
+		ei_x_print_msg(buf, to, 1);
+#endif
+        ret = ei_send(ei_node->nodefd, to, buf->buff, buf->index);
+    }
+
+    return ret;
+}
+
+int ei_decode_atom_safe(char *buf, int *index, char *dst) {
+    int type, size;
+
+    ei_get_type(buf, index, &type, &size);
+	
+	if (type != ERL_ATOM_EXT) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unexpected erlang term type %d (size %d), needed atom\n", type, size);
+        return -1;
+	} else if (size > MAXATOMLEN) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Requested decoding of atom with size %d into a buffer of size %d\n", size, MAXATOMLEN);
+        return -1;
+	} else {
+		return ei_decode_atom(buf, index, dst);
+	}
+}
+
+int ei_decode_string_or_binary(char *buf, int *index, char **dst) {
+    int type, size, res;
+    long len;
+
+    ei_get_type(buf, index, &type, &size);
+
+    if (type != ERL_STRING_EXT && type != ERL_BINARY_EXT && type != ERL_NIL_EXT) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unexpected erlang term type %d (size %d), needed binary or string\n", type, size);
+        return -1;
+    }
+
+	*dst = malloc(size + 1);
+
+	if (type == ERL_NIL_EXT) {
+		res = 0;
+		**dst = '\0';
+	} else if (type == ERL_BINARY_EXT) {
+        res = ei_decode_binary(buf, index, *dst, &len);
+        (*dst)[len] = '\0'; /* binaries aren't null terminated */
+    } else {
+        res = ei_decode_string(buf, index, *dst);
+    }
+
+    return res;
+}
+
+int ei_decode_string_or_binary_limited(char *buf, int *index, int maxsize, char *dst) {
+    int type, size, res;
+    long len;
+
+    ei_get_type(buf, index, &type, &size);
+
+    if (type != ERL_STRING_EXT && type != ERL_BINARY_EXT && type != ERL_NIL_EXT) {
+        switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unexpected erlang term type %d (size %d), needed binary or string\n", type, size);
+        return -1;
+    }
+
+	if (size > maxsize) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Requested decoding of %s with size %d into a buffer of size %d\n",
+						  type == ERL_BINARY_EXT ? "binary" : "string", size, maxsize);
+		return -1;
+	}
+
+	if (type == ERL_NIL_EXT) {
+		res = 0;
+		dst = '\0';
+	} else if (type == ERL_BINARY_EXT) {
+        res = ei_decode_binary(buf, index, dst, &len);
+        dst[len] = '\0'; /* binaries aren't null terminated */
+    } else {
+        res = ei_decode_string(buf, index, dst);
+    }
+
+    return res;
+}
+
+switch_event_t *create_default_filter() {
+	switch_event_t *filter;
+
+//	switch_event_create_subclass(&filter, SWITCH_EVENT_CUSTOM, "mod_kazoo::filter");
+	switch_event_create(&filter, SWITCH_EVENT_CUSTOM);
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Acquired-UUID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "action", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Action", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "alt_event_type", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Answer-State", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Application", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Application-Data", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Application-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Application-Response", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "att_xfer_replaced_by", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Auth-Method", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Auth-Realm", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Auth-User", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Bridge-A-Unique-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Bridge-B-Unique-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Call-Direction", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Callee-ID-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Callee-ID-Number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Caller-ID-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Caller-ID-Number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Context", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Controls", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Destination-Number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Dialplan", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Network-Addr", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Caller-Unique-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Call-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Channel-Call-State", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Channel-Call-UUID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Channel-Presence-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Channel-State", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Chat-Permissions", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Conference-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Conference-Profile-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Conference-Unique-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "contact", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Detected-Tone", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "dialog_state", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "direction", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Distributed-From", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "DTMF-Digit", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "DTMF-Duration", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Event-Date-Timestamp", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Event-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Event-Subclass", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "expires", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Expires", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Ext-SIP-IP", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "File", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "FreeSWITCH-Hostname", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "from", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Hunt-Destination-Number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "ip", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Message-Account", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "metadata", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "old_node_channel_uuid", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Other-Leg-Callee-ID-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Other-Leg-Callee-ID-Number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Other-Leg-Caller-ID-Name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Other-Leg-Caller-ID-Number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Other-Leg-Destination-Number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Other-Leg-Direction", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Other-Leg-Unique-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Participant-Type", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Path", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "profile_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Profiles", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "proto-specific-event-name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Raw-Application-Data", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "realm", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Resigning-UUID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "set", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_auto_answer", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_auth_method", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_from_host", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_from_user", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_to_host", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_to_user", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sub-call-id", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "technology", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "to", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "Unique-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "URL", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "username", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_channel_is_moving", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_collected_digits", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_current_application", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_current_application_data", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_domain_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_effective_caller_id_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_effective_caller_id_number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_bad_rows", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_document_total_pages", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_document_transferred_pages", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_ecm_used", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_result_code", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_result_text", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_success", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_fax_transfer_rate", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_holding_uuid", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_hold_music", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_media_group_id", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_originate_disposition", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_playback_terminator_used", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_presence_id", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_record_ms", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_recovered", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_silence_hits_exhausted", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sip_auth_realm", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sip_from_host", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sip_from_user", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sip_h_X-AUTH-IP", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sip_received_ip", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sip_to_host", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sip_to_user", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_sofia_profile_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_transfer_history", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_user_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_endpoint_disposition", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_originate_disposition", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_bridge_hangup_cause", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_hangup_cause", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_last_bridge_proto_specific_hangup_cause", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "variable_proto_specific_hangup_cause", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "VM-Call-ID", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "VM-sub-call-id", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "whistle_application_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "whistle_application_response", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "whistle_event_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_auto_answer_notify", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "eavesdrop_group", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "origination_caller_id_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "origination_caller_id_number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "origination_callee_id_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "origination_callee_id_number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_auth_username", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "sip_auth_password", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "effective_caller_id_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "effective_caller_id_number", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "effective_callee_id_name", "undefined");
+	switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, "effective_callee_id_number", "undefined");
+
+	return filter;
+}
+
+/* For Emacs:
+ * Local Variables:
+ * mode:c
+ * indent-tabs-mode:t
+ * tab-width:4
+ * c-basic-offset:4
+ * End:
+ * For VIM:
+ * vim:set softtabstop=4 shiftwidth=4 tabstop=4:
+ */
diff --git a/src/mod/event_handlers/mod_kazoo/mod_kazoo.c b/src/mod/event_handlers/mod_kazoo/mod_kazoo.c
new file mode 100644
index 0000000..db50ce9
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/mod_kazoo.c
@@ -0,0 +1,705 @@
+/*
+ * FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ * Copyright (C) 2005-2012, Anthony Minessale II <anthm@freeswitch.org>
+ *
+ * Version: MPL 1.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is FreeSWITCH Modular Media Switching Software Library / Soft-Switch Application
+ *
+ * The Initial Developer of the Original Code is
+ * Anthony Minessale II <anthm@freeswitch.org>
+ * Portions created by the Initial Developer are Copyright (C)
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ *
+ * Karl Anderson <karl@2600hz.com>
+ * Darren Schreiber <darren@2600hz.com>
+ *
+ *
+ * mod_kazoo.c -- Socket Controlled Event Handler
+ *
+ */
+#include "mod_kazoo.h"
+
+SWITCH_MODULE_LOAD_FUNCTION(mod_kazoo_load);
+SWITCH_MODULE_SHUTDOWN_FUNCTION(mod_kazoo_shutdown);
+SWITCH_MODULE_RUNTIME_FUNCTION(mod_kazoo_runtime);
+SWITCH_MODULE_DEFINITION(mod_kazoo, mod_kazoo_load, mod_kazoo_shutdown, mod_kazoo_runtime);
+
+SWITCH_DECLARE_GLOBAL_STRING_FUNC(set_pref_ip, globals.ip);
+SWITCH_DECLARE_GLOBAL_STRING_FUNC(set_pref_ei_cookie, globals.ei_cookie);
+SWITCH_DECLARE_GLOBAL_STRING_FUNC(set_pref_ei_nodename, globals.ei_nodename);
+SWITCH_DECLARE_GLOBAL_STRING_FUNC(set_pref_kazoo_var_prefix, globals.kazoo_var_prefix);
+
+static switch_status_t api_erlang_status(switch_stream_handle_t *stream) {
+	switch_sockaddr_t *sa;
+	uint16_t port;
+	char ipbuf[25];
+	const char *ip_addr;
+	ei_node_t *ei_node;
+
+	switch_socket_addr_get(&sa, SWITCH_FALSE, globals.acceptor);
+
+	port = switch_sockaddr_get_port(sa);
+	ip_addr = switch_get_addr(ipbuf, sizeof (ipbuf), sa);
+
+	stream->write_function(stream, "Running %s\n", VERSION);
+	stream->write_function(stream, "Listening for new Erlang connections on %s:%u with cookie %s\n", ip_addr, port, globals.ei_cookie);
+	stream->write_function(stream, "Registered as Erlang node %s, visible as %s\n", globals.ei_cnode.thisnodename, globals.ei_cnode.thisalivename);
+
+	if (globals.ei_compat_rel) {
+		stream->write_function(stream, "Using Erlang compatibility mode: %d\n", globals.ei_compat_rel);
+	}
+
+	switch_thread_rwlock_rdlock(globals.ei_nodes_lock);
+	ei_node = globals.ei_nodes;
+	if (!ei_node) {
+		stream->write_function(stream, "No erlang nodes connected\n");
+	} else {
+		stream->write_function(stream, "Connected to:\n");
+		while(ei_node != NULL) {
+			unsigned int year, day, hour, min, sec, delta;
+
+			delta = (switch_micro_time_now() - ei_node->created_time) / 1000000;
+			sec = delta % 60; 
+			min = delta / 60 % 60; 
+			hour = delta / 3600 % 24; 
+			day = delta / 86400 % 7;
+			year = delta / 31556926 % 12;
+			stream->write_function(stream, "  %s (%s:%d) up %d years, %d days, %d hours, %d minutes, %d seconds\n"
+								   ,ei_node->peer_nodename, ei_node->remote_ip, ei_node->remote_port, year, day, hour, min, sec);
+			ei_node = ei_node->next;
+		}
+	}
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t api_erlang_event_filter(switch_stream_handle_t *stream) {
+	switch_event_header_t *header;
+	int column = 0;
+
+	for (header = globals.event_filter->headers; header; header = header->next) {
+		stream->write_function(stream, "%-50s", header->name);
+		if (++column > 2) {			
+			stream->write_function(stream, "\n");
+			column = 0;
+		}
+	}
+
+	if (++column > 2) {			
+		stream->write_function(stream, "\n");
+		column = 0;
+	}
+
+	stream->write_function(stream, "%-50s", globals.kazoo_var_prefix);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t api_erlang_nodes_list(switch_stream_handle_t *stream) {
+	ei_node_t *ei_node;
+
+	switch_thread_rwlock_rdlock(globals.ei_nodes_lock);
+	ei_node = globals.ei_nodes;
+	while(ei_node != NULL) {
+		stream->write_function(stream, "%s (%s)\n", ei_node->peer_nodename, ei_node->remote_ip);
+		ei_node = ei_node->next;
+	}
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t api_erlang_nodes_count(switch_stream_handle_t *stream) {
+	ei_node_t *ei_node;
+	int count = 0;
+
+	switch_thread_rwlock_rdlock(globals.ei_nodes_lock);
+	ei_node = globals.ei_nodes;
+	while(ei_node != NULL) {
+		count++;
+		ei_node = ei_node->next;
+	}
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+
+	stream->write_function(stream, "%d\n", count);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t api_complete_erlang_node(const char *line, const char *cursor, switch_console_callback_match_t **matches) {
+	switch_console_callback_match_t *my_matches = NULL;
+	switch_status_t status = SWITCH_STATUS_FALSE;
+	ei_node_t *ei_node;
+
+	switch_thread_rwlock_rdlock(globals.ei_nodes_lock);
+	ei_node = globals.ei_nodes;
+	while(ei_node != NULL) {
+		switch_console_push_match(&my_matches, ei_node->peer_nodename);
+		ei_node = ei_node->next;
+	}
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+
+	if (my_matches) {
+		*matches = my_matches;
+		status = SWITCH_STATUS_SUCCESS;
+	}
+
+	return status;
+}
+
+static switch_status_t handle_node_api_event_stream(ei_event_stream_t *event_stream, switch_stream_handle_t *stream) {
+	ei_event_binding_t *binding;
+	int column = 0;
+
+	switch_mutex_lock(event_stream->socket_mutex);
+	if (event_stream->connected == SWITCH_FALSE) {
+		switch_sockaddr_t *sa;		
+		uint16_t port;
+		char ipbuf[25];
+		const char *ip_addr;
+
+		switch_socket_addr_get(&sa, SWITCH_TRUE, event_stream->acceptor);
+		port = switch_sockaddr_get_port(sa);
+		ip_addr = switch_get_addr(ipbuf, sizeof (ipbuf), sa);
+
+		if (zstr(ip_addr)) {
+			ip_addr = globals.ip;
+		}
+
+		stream->write_function(stream, "%s:%d -> disconnected\n", ip_addr, port);
+
+		switch_mutex_unlock(event_stream->socket_mutex);
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	stream->write_function(stream, "%s:%d -> %s:%d\n"
+						   ,event_stream->local_ip, event_stream->local_port
+						   ,event_stream->remote_ip, event_stream->remote_port);
+
+	binding = event_stream->bindings;
+	while(binding != NULL) {
+		if (binding->type == SWITCH_EVENT_CUSTOM) {
+			stream->write_function(stream, "CUSTOM %-43s", binding->subclass_name);
+		} else {
+			stream->write_function(stream, "%-50s", switch_event_name(binding->type));
+		}
+
+		if (++column > 2) {			
+			stream->write_function(stream, "\n");
+			column = 0;
+		}
+
+		binding = binding->next;
+	}
+	switch_mutex_unlock(event_stream->socket_mutex);
+
+	if (!column) {
+		stream->write_function(stream, "\n");
+	} else {
+		stream->write_function(stream, "\n\n");
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_node_api_event_streams(ei_node_t *ei_node, switch_stream_handle_t *stream) {
+	ei_event_stream_t *event_stream;
+
+	switch_mutex_lock(ei_node->event_streams_mutex);
+	event_stream = ei_node->event_streams;
+	while(event_stream != NULL) {
+		handle_node_api_event_stream(event_stream, stream);
+		event_stream = event_stream->next;
+	}
+	switch_mutex_unlock(ei_node->event_streams_mutex);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t handle_node_api_command(ei_node_t *ei_node, switch_stream_handle_t *stream, uint32_t command) {
+	unsigned int year, day, hour, min, sec, delta;
+
+	switch (command) {
+	case API_COMMAND_DISCONNECT:
+		stream->write_function(stream, "Disconnecting erlang node %s at managers request\n", ei_node->peer_nodename);
+		switch_clear_flag(ei_node, LFLAG_RUNNING);
+		break;
+	case API_COMMAND_REMOTE_IP:
+		delta = (switch_micro_time_now() - ei_node->created_time) / 1000000;
+		sec = delta % 60; 
+		min = delta / 60 % 60; 
+		hour = delta / 3600 % 24; 
+		day = delta / 86400 % 7;
+		year = delta / 31556926 % 12;
+
+		stream->write_function(stream, "Uptime           %d years, %d days, %d hours, %d minutes, %d seconds\n", year, day, hour, min, sec);
+		stream->write_function(stream, "Local Address    %s:%d\n", ei_node->local_ip, ei_node->local_port);
+		stream->write_function(stream, "Remote Address   %s:%d\n", ei_node->remote_ip, ei_node->remote_port);
+		break;
+	case API_COMMAND_STREAMS:
+		handle_node_api_event_streams(ei_node, stream);
+		break;
+	case API_COMMAND_BINDINGS:
+		handle_api_command_streams(ei_node, stream);
+		break;
+	default:
+		break;
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t api_erlang_node_command(switch_stream_handle_t *stream, const char *nodename, uint32_t command) {
+	ei_node_t *ei_node;
+
+	switch_thread_rwlock_rdlock(globals.ei_nodes_lock);
+	ei_node = globals.ei_nodes;
+	while(ei_node != NULL) {
+		int length = strlen(ei_node->peer_nodename);
+
+		if (!strncmp(ei_node->peer_nodename, nodename, length)) {
+			handle_node_api_command(ei_node, stream, command);
+			switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+			return SWITCH_STATUS_SUCCESS;
+		}
+
+		ei_node = ei_node->next;
+	}
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+	
+	return SWITCH_STATUS_NOTFOUND;
+}
+
+static int read_cookie_from_file(char *filename) {
+	int fd;
+	char cookie[MAXATOMLEN + 1];
+	char *end;
+	struct stat buf;
+	ssize_t res;
+
+	if (!stat(filename, &buf)) {
+		if ((buf.st_mode & S_IRWXG) || (buf.st_mode & S_IRWXO)) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "%s must only be accessible by owner only.\n", filename);
+			return 2;
+		}
+		if (buf.st_size > MAXATOMLEN) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "%s contains a cookie larger than the maximum atom size of %d.\n", filename, MAXATOMLEN);
+			return 2;
+		}
+		fd = open(filename, O_RDONLY);
+		if (fd < 1) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unable to open cookie file %s : %d.\n", filename, errno);
+			return 2;
+		}
+
+		if ((res = read(fd, cookie, MAXATOMLEN)) < 1) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unable to read cookie file %s : %d.\n", filename, errno);
+		}
+
+		cookie[MAXATOMLEN] = '\0';
+
+		/* replace any end of line characters with a null */
+		if ((end = strchr(cookie, '\n'))) {
+			*end = '\0';
+		}
+
+		if ((end = strchr(cookie, '\r'))) {
+			*end = '\0';
+		}
+
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO, "Set cookie from file %s: %s\n", filename, cookie);
+
+		set_pref_ei_cookie(cookie);
+		return 0;
+	} else {
+		/* don't error here, because we might be blindly trying to read $HOME/.erlang.cookie, and that can fail silently */
+		return 1;
+	}
+}
+
+static switch_status_t config(void) {
+	char *cf = "kazoo.conf";
+	switch_xml_t cfg, xml, child, param;
+
+	if (!(xml = switch_xml_open_cfg(cf, &cfg, NULL))) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Failed to open configuration file %s\n", cf);
+		return SWITCH_STATUS_FALSE;
+	} else {
+		if ((child = switch_xml_child(cfg, "settings"))) {
+			for (param = switch_xml_child(child, "param"); param; param = param->next) {
+				char *var = (char *) switch_xml_attr_soft(param, "name");
+				char *val = (char *) switch_xml_attr_soft(param, "value");
+
+				if (!strcmp(var, "listen-ip")) {
+					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO, "Set bind ip address: %s\n", val);
+					set_pref_ip(val);
+				} else if (!strcmp(var, "cookie")) {
+					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO, "Set cookie: %s\n", val);
+					set_pref_ei_cookie(val);
+				} else if (!strcmp(var, "cookie-file")) {
+					if (read_cookie_from_file(val) == 1) {
+						switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unable to read cookie from %s\n", val);
+					}
+				} else if (!strcmp(var, "nodename")) {
+					switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_INFO, "Set node name: %s\n", val);
+					set_pref_ei_nodename(val);
+				} else if (!strcmp(var, "shortname")) {
+					globals.ei_shortname = switch_true(val);
+				} else if (!strcmp(var, "kazoo-var-prefix")) {
+					set_pref_kazoo_var_prefix(val);
+				} else if (!strcmp(var, "compat-rel")) {
+					if (atoi(val) >= 7)
+						globals.ei_compat_rel = atoi(val);
+					else
+						switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Invalid compatibility release '%s' specified\n", val);
+				} else if (!strcmp(var, "nat-map")) {
+					globals.nat_map = switch_true(val);
+				}
+			}
+		}
+		if ((child = switch_xml_child(cfg, "event-filter"))) {
+			switch_event_t *filter;
+
+			switch_event_create(&filter, SWITCH_EVENT_CUSTOM);
+			for (param = switch_xml_child(child, "header"); param; param = param->next) {
+				char *var = (char *) switch_xml_attr_soft(param, "name");
+				switch_event_add_header_string(filter, SWITCH_STACK_BOTTOM, var, "undefined");
+			}
+
+			globals.event_filter = filter;
+		}
+
+		switch_xml_free(xml);
+	}
+
+	if (!globals.event_filter) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "Event filter not found in configuration, using default\n");
+		globals.event_filter = create_default_filter();
+	}
+
+	if (zstr(globals.kazoo_var_prefix)) {
+		set_pref_kazoo_var_prefix("variable_ecallmgr*");
+		globals.var_prefix_length = 17; //ignore the *
+	} else {
+		/* we could use the global pool but then we would have to conditionally
+		 * free the pointer if it was not drawn from the XML */
+		char *buf;
+		int size = switch_snprintf(NULL, 0, "variable_%s*", globals.kazoo_var_prefix) + 1;
+
+		switch_malloc(buf, size);
+		switch_snprintf(buf, size, "variable_%s*", globals.kazoo_var_prefix);
+		switch_safe_free(globals.kazoo_var_prefix);
+		globals.kazoo_var_prefix = buf;
+		globals.var_prefix_length = size - 2; //ignore the *
+	}
+
+	if (zstr(globals.ip)) {
+		set_pref_ip("0.0.0.0");
+	}
+
+	if (zstr(globals.ei_cookie)) {
+		int res;
+		char *home_dir = getenv("HOME");
+		char path_buf[1024];
+
+		if (!zstr(home_dir)) {
+			/* $HOME/.erlang.cookie */
+			switch_snprintf(path_buf, sizeof (path_buf), "%s%s%s", home_dir, SWITCH_PATH_SEPARATOR, ".erlang.cookie");
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Checking for cookie at path: %s\n", path_buf);
+
+			res = read_cookie_from_file(path_buf);
+			if (res) {
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "No cookie or valid cookie file specified, using default cookie\n");
+				set_pref_ei_cookie("ClueCon");
+			}
+		}
+	}
+
+	if (!globals.ei_nodename) {
+		set_pref_ei_nodename("freeswitch");
+	}
+
+	if (!globals.nat_map) {
+		globals.nat_map = 0;
+	}
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+static switch_status_t create_acceptor() {
+	switch_sockaddr_t *sa;
+	uint16_t port;
+    char ipbuf[25];
+    const char *ip_addr;
+
+	/* if the config has specified an erlang release compatibility then pass that along to the erlang interface */
+	if (globals.ei_compat_rel) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Compatability with OTP R%d requested\n", globals.ei_compat_rel);
+		ei_set_compat_rel(globals.ei_compat_rel);
+	}
+
+	if (!(globals.acceptor = create_socket(globals.pool))) {
+		return SWITCH_STATUS_SOCKERR;
+	}
+
+	switch_socket_addr_get(&sa, SWITCH_FALSE, globals.acceptor);
+
+	port = switch_sockaddr_get_port(sa);
+    ip_addr = switch_get_addr(ipbuf, sizeof (ipbuf), sa);
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Erlang connection acceptor listening on %s:%u\n", ip_addr, port);
+
+	/* try to initialize the erlang interface */
+	if (create_ei_cnode(ip_addr, globals.ei_nodename, &globals.ei_cnode) != SWITCH_STATUS_SUCCESS) {
+		return SWITCH_STATUS_SOCKERR;
+	}
+
+	/* tell the erlang port manager where we can be reached.  this returns a file descriptor pointing to epmd or -1 */
+	if ((globals.epmdfd = ei_publish(&globals.ei_cnode, port)) == -1) {
+		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR,
+						  "Failed to publish port to epmd. Try starting it yourself or run an erl shell with the -sname or -name option.\n");
+		return SWITCH_STATUS_SOCKERR;
+	}
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Connected to epmd and published erlang cnode name %s at port %d\n", globals.ei_cnode.thisnodename, port);
+
+	return SWITCH_STATUS_SUCCESS;
+}
+ 
+SWITCH_STANDARD_API(exec_api_cmd)
+{
+	char *argv[1024] = { 0 };
+	int unknown_command = 1, argc = 0;
+	char *mycmd = NULL;
+
+	const char *usage_string = "USAGE:\n"
+		"--------------------------------------------------------------------------------------------------------------------\n"
+		"erlang status                            - provides an overview of the current status\n"
+		"erlang event_filter                      - lists the event headers that will be sent to Erlang nodes\n"
+		"erlang nodes list                        - lists connected Erlang nodes (usefull for monitoring tools)\n"
+		"erlang nodes count                       - provides a count of connected Erlang nodes (usefull for monitoring tools)\n"
+		"erlang node <node_name> disconnect       - disconnects an Erlang node\n"
+		"erlang node <node_name> connection       - Shows the connection info\n"
+		"erlang node <node_name> event_streams    - lists the event streams for an Erlang node\n"
+		"erlang node <node_name> fetch_bindings   - lists the XML fetch bindings for an Erlang node\n"
+		"---------------------------------------------------------------------------------------------------------------------\n";
+
+	if (zstr(cmd)) {
+		stream->write_function(stream, "%s", usage_string);
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	if (!(mycmd = strdup(cmd))) {
+		return SWITCH_STATUS_MEMERR;
+	}
+
+	if (!(argc = switch_separate_string(mycmd, ' ', argv, (sizeof(argv) / sizeof(argv[0]))))) {
+		stream->write_function(stream, "%s", usage_string);
+		switch_safe_free(mycmd);
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	if (zstr(argv[0])) {
+		stream->write_function(stream, "%s", usage_string);
+		switch_safe_free(mycmd);
+		return SWITCH_STATUS_SUCCESS;
+	}
+
+	if (!strncmp(argv[0], "status", 6)) {
+		unknown_command = 0;
+		api_erlang_status(stream);
+	} else if (!strncmp(argv[0], "event_filter", 6)) {
+		unknown_command = 0;
+		api_erlang_event_filter(stream);
+	} else if (!strncmp(argv[0], "nodes", 6) && !zstr(argv[1])) {
+		if (!strncmp(argv[1], "list", 6)) {
+			unknown_command = 0;
+			api_erlang_nodes_list(stream);
+		} else if (!strncmp(argv[1], "count", 6)) {
+			unknown_command = 0;
+			api_erlang_nodes_count(stream);
+		}
+	} else if (!strncmp(argv[0], "node", 6) && !zstr(argv[1]) && !zstr(argv[2])) {
+		if (!strncmp(argv[2], "disconnect", 6)) {
+			unknown_command = 0;
+			api_erlang_node_command(stream, argv[1], API_COMMAND_DISCONNECT);
+		} else if (!strncmp(argv[2], "connection", 2)) {
+			unknown_command = 0;
+			api_erlang_node_command(stream, argv[1], API_COMMAND_REMOTE_IP);
+		} else if (!strncmp(argv[2], "event_streams", 6)) {
+			unknown_command = 0;
+			api_erlang_node_command(stream, argv[1], API_COMMAND_STREAMS);
+		} else if (!strncmp(argv[2], "fetch_bindings", 6)) {
+			unknown_command = 0;
+			api_erlang_node_command(stream, argv[1], API_COMMAND_BINDINGS);
+		}
+	}
+
+	if (unknown_command) {
+		stream->write_function(stream, "%s", usage_string);
+	}
+
+	switch_safe_free(mycmd);
+	return SWITCH_STATUS_SUCCESS;
+}
+
+SWITCH_MODULE_LOAD_FUNCTION(mod_kazoo_load) {
+	switch_api_interface_t *api_interface;
+
+	memset(&globals, 0, sizeof(globals));
+
+	globals.pool = pool;
+
+	if(config() != SWITCH_STATUS_SUCCESS) {
+		// TODO: what would we need to clean up here?
+		return SWITCH_STATUS_TERM;
+	}
+
+	if(create_acceptor() != SWITCH_STATUS_SUCCESS) {
+		// TODO: what would we need to clean up here
+		close_socket(&globals.acceptor);
+		return SWITCH_STATUS_TERM;
+	}
+
+	/* connect my internal structure to the blank pointer passed to me */
+	*module_interface = switch_loadable_module_create_module_interface(pool, modname);
+
+	/* create an api for cli debug commands */
+	SWITCH_ADD_API(api_interface, "erlang", "kazoo information", exec_api_cmd, "<command> [<args>]");
+	switch_console_set_complete("add erlang status");
+	switch_console_set_complete("add erlang event_filter");
+	switch_console_set_complete("add erlang nodes list");
+	switch_console_set_complete("add erlang nodes count");
+	switch_console_set_complete("add erlang node ::erlang::node disconnect");
+	switch_console_set_complete("add erlang node ::erlang::node connection");
+	switch_console_set_complete("add erlang node ::erlang::node event_streams");
+	switch_console_set_complete("add erlang node ::erlang::node fetch_bindings");
+	switch_console_add_complete_func("::erlang::node", api_complete_erlang_node);
+
+	switch_thread_rwlock_create(&globals.ei_nodes_lock, pool);
+
+	switch_set_flag(&globals, LFLAG_RUNNING);
+
+	/* create all XML fetch agents */
+	bind_fetch_agents();
+
+	/* indicate that the module should continue to be loaded */
+	return SWITCH_STATUS_SUCCESS;
+}
+
+SWITCH_MODULE_SHUTDOWN_FUNCTION(mod_kazoo_shutdown) {
+	int sanity = 0;
+
+	switch_console_set_complete("del erlang");
+	switch_console_del_complete_func("::erlang::node");
+
+	/* stop taking new requests and start shuting down the threads */
+	switch_clear_flag(&globals, LFLAG_RUNNING);
+	
+	/* give everyone time to cleanly shutdown */
+	while (switch_atomic_read(&globals.threads)) {
+		switch_yield(100000);
+		if (++sanity >= 200) {
+			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Unable to kill all threads, continuing. This probably wont end well.....good luck!\n");
+			break;
+		}
+	}
+
+	if (globals.event_filter) {
+		switch_event_destroy(&globals.event_filter);
+	}
+
+	switch_thread_rwlock_wrlock(globals.ei_nodes_lock);
+	switch_thread_rwlock_unlock(globals.ei_nodes_lock);
+	switch_thread_rwlock_destroy(globals.ei_nodes_lock);
+
+	/* close the connection to epmd and the acceptor */
+	close_socketfd(&globals.epmdfd);
+	close_socket(&globals.acceptor);
+
+	/* remove all XML fetch agents */
+	unbind_fetch_agents();
+
+	/* Close the port we reserved for uPnP/Switch behind firewall, if necessary */
+	//	if (globals.nat_map && switch_nat_get_type()) {
+	//		switch_nat_del_mapping(globals.port, SWITCH_NAT_TCP);
+	//	}
+
+	/* clean up our allocated preferences */
+	switch_safe_free(globals.ip);
+	switch_safe_free(globals.ei_cookie);
+	switch_safe_free(globals.ei_nodename);
+	switch_safe_free(globals.kazoo_var_prefix); 
+
+	return SWITCH_STATUS_SUCCESS;
+}
+
+SWITCH_MODULE_RUNTIME_FUNCTION(mod_kazoo_runtime) {
+	switch_os_socket_t os_socket;
+		
+	switch_atomic_inc(&globals.threads);
+
+	switch_os_sock_get(&os_socket, globals.acceptor);
+
+	while (switch_test_flag(&globals, LFLAG_RUNNING)) {
+		int nodefd;
+		ErlConnect conn;
+
+		/* zero out errno because ei_accept doesn't differentiate between a */
+		/* failed authentication or a socket failure, or a client version */
+		/* mismatch or a godzilla attack (and a godzilla attack is highly likely) */
+		errno = 0;
+
+		/* wait here for an erlang node to connect, timming out to check if our module is still running every now-and-again */
+		if ((nodefd = ei_accept_tmo(&globals.ei_cnode, (int) os_socket, &conn, 500)) == ERL_ERROR) {
+			if (erl_errno == ETIMEDOUT) {
+				continue;
+			} else if (errno) {
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "Erlang connection acceptor socket error %d %d\n", erl_errno, errno);
+			} else {
+				switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING,
+						"Erlang node connection failed - ensure your cookie matches '%s' and you are using a good nodename\n", globals.ei_cookie);
+			}
+			continue;
+		}
+
+		if (!switch_test_flag(&globals, LFLAG_RUNNING)) {
+			break;
+		}
+
+		/* NEW ERLANG NODE CONNECTION! Hello friend! */
+		new_kazoo_node(nodefd, &conn);
+	}
+
+	switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_DEBUG, "Erlang connection acceptor shut down\n");
+
+	switch_atomic_dec(&globals.threads);
+
+	return SWITCH_STATUS_TERM;
+}
+
+
+/* For Emacs:
+ * Local Variables:
+ * mode:c
+ * indent-tabs-mode:t
+ * tab-width:4
+ * c-basic-offset:4
+ * End:
+ * For VIM:
+ * vim:set softtabstop=4 shiftwidth=4 tabstop=4:
+ */
diff --git a/src/mod/event_handlers/mod_kazoo/mod_kazoo.h b/src/mod/event_handlers/mod_kazoo/mod_kazoo.h
new file mode 100644
index 0000000..29a1e3c
--- /dev/null
+++ b/src/mod/event_handlers/mod_kazoo/mod_kazoo.h
@@ -0,0 +1,155 @@
+#include <switch.h>
+#include <ei.h>
+
+#define MAX_ACL 100
+#define CMD_BUFLEN 1024 * 1000
+#define MAX_QUEUE_LEN 25000
+#define MAX_MISSED 500
+#define MAX_PID_CHARS 255
+#define VERSION "mod_kazoo v2.14.0"
+
+#define API_COMMAND_DISCONNECT 0
+#define API_COMMAND_REMOTE_IP 1
+#define API_COMMAND_STREAMS 2
+#define API_COMMAND_BINDINGS 3
+
+typedef enum {
+	LFLAG_RUNNING = (1 << 0)
+} event_flag_t;
+
+struct ei_asynchronous_msg_s {
+	ei_x_buff ebuf;
+	erlang_pid pid;	
+};
+typedef struct ei_asynchronous_msg_s ei_asynchronous_msg_t;
+
+struct ei_event_binding_s {
+	char id[SWITCH_UUID_FORMATTED_LENGTH + 1];
+	switch_event_node_t *node;
+	switch_event_types_t type;
+	const char *subclass_name;
+	struct ei_event_binding_s *next;
+};
+typedef struct ei_event_binding_s ei_event_binding_t;
+
+struct ei_event_stream_s {
+	switch_memory_pool_t *pool;
+	ei_event_binding_t *bindings;
+	switch_queue_t *queue;
+	switch_socket_t *acceptor;
+	switch_pollset_t *pollset;
+	switch_pollfd_t *pollfd;
+	switch_socket_t *socket;
+	switch_mutex_t *socket_mutex;
+	switch_bool_t connected;	
+    const char *remote_ip;
+	uint16_t remote_port;
+    const char *local_ip;
+	uint16_t local_port;
+	erlang_pid pid;
+	uint32_t flags;
+	struct ei_event_stream_s *next;
+};
+typedef struct ei_event_stream_s ei_event_stream_t;
+
+struct ei_node_s {
+	int nodefd;
+	switch_atomic_t pending_bgapi;
+	switch_memory_pool_t *pool;
+	ei_event_stream_t *event_streams;
+	switch_mutex_t *event_streams_mutex;
+	switch_queue_t *asynchronous_msgs;
+	char *peer_nodename;
+	switch_time_t created_time;
+	switch_socket_t *socket;
+    const char *remote_ip;
+	uint16_t remote_port;
+    const char *local_ip;
+	uint16_t local_port;
+	uint32_t flags;
+	struct ei_node_s *next;
+};
+typedef struct ei_node_s ei_node_t;
+
+/*
+struct nat_map_s {
+	int nat_map;
+	struct nat_map_s *next;
+};
+typedef struct nat_map_s nat_map_t;
+*/
+
+struct globals_s {
+	switch_memory_pool_t *pool;
+	switch_atomic_t threads;
+	switch_socket_t *acceptor;
+	struct ei_cnode_s ei_cnode;
+	switch_thread_rwlock_t *ei_nodes_lock;
+	ei_node_t *ei_nodes;
+	switch_xml_binding_t *config_fetch_binding;
+	switch_xml_binding_t *directory_fetch_binding;
+	switch_xml_binding_t *dialplan_fetch_binding;
+	switch_xml_binding_t *chatplan_fetch_binding;
+	switch_event_t *event_filter;
+	int epmdfd;
+	switch_bool_t nat_map;
+	switch_bool_t ei_shortname;
+	int ei_compat_rel;
+	char *ip;
+	char *ei_cookie;
+	char *ei_nodename;
+	char *kazoo_var_prefix;
+	int var_prefix_length;
+	uint32_t flags;
+} globals;
+typedef struct globals_s globals_t;
+
+/* kazoo_node.c */
+switch_status_t new_kazoo_node(int nodefd, ErlConnect *conn);
+
+/* kazoo_event_stream.c */
+ei_event_stream_t *find_event_stream(ei_event_stream_t *event_streams, const erlang_pid *from);
+ei_event_stream_t *new_event_stream(ei_event_stream_t **event_streams, const erlang_pid *from);
+switch_status_t remove_event_stream(ei_event_stream_t **event_streams, const erlang_pid *from);
+switch_status_t remove_event_streams(ei_event_stream_t **event_streams);
+unsigned long get_stream_port(const ei_event_stream_t *event_stream);
+switch_status_t add_event_binding(ei_event_stream_t *event_stream, const switch_event_types_t event_type, const char *subclass_name);
+switch_status_t remove_event_binding(ei_event_stream_t *event_stream, const switch_event_types_t event_type, const char *subclass_name);
+switch_status_t remove_event_bindings(ei_event_stream_t *event_stream);
+
+/* kazoo_fetch_agent.c */
+switch_status_t bind_fetch_agents();
+switch_status_t unbind_fetch_agents();
+switch_status_t remove_xml_clients(ei_node_t *ei_node);
+switch_status_t add_fetch_handler(ei_node_t *ei_node, erlang_pid *from, switch_xml_binding_t *binding);
+switch_status_t remove_fetch_handlers(ei_node_t *ei_node, erlang_pid *from);
+switch_status_t fetch_reply(char *uuid_str, char *xml_str, switch_xml_binding_t *binding);
+switch_status_t handle_api_command_streams(ei_node_t *ei_node, switch_stream_handle_t *stream);
+
+/* kazoo_utils.c */
+void close_socket(switch_socket_t **sock);
+void close_socketfd(int *sockfd);
+switch_socket_t *create_socket(switch_memory_pool_t *pool);
+switch_status_t create_ei_cnode(const char *ip_addr, const char *name, struct ei_cnode_s *ei_cnode);
+switch_status_t ei_compare_pids(const erlang_pid *pid1, const erlang_pid *pid2);
+void ei_encode_switch_event_headers(ei_x_buff *ebuf, switch_event_t *event);
+void ei_link(ei_node_t *ei_node, erlang_pid * from, erlang_pid * to);
+void ei_encode_switch_event(ei_x_buff * ebuf, switch_event_t *event);
+int ei_helper_send(ei_node_t *ei_node, erlang_pid* to, ei_x_buff *buf);
+int ei_decode_atom_safe(char *buf, int *index, char *dst);
+int ei_decode_string_or_binary_limited(char *buf, int *index, int maxsize, char *dst);
+int ei_decode_string_or_binary(char *buf, int *index, char **dst);
+switch_event_t *create_default_filter();
+
+#define _ei_x_encode_string(buf, string) { ei_x_encode_binary(buf, string, strlen(string)); }
+
+/* For Emacs:
+ * Local Variables:
+ * mode:c
+ * indent-tabs-mode:t
+ * tab-width:4
+ * c-basic-offset:4
+ * End:
+ * For VIM:
+ * vim:set softtabstop=4 shiftwidth=4 tabstop=4:
+ */
diff --git a/src/switch_apr.c b/src/switch_apr.c
index aeb1018..fff556c 100644
--- a/src/switch_apr.c
+++ b/src/switch_apr.c
@@ -678,6 +678,11 @@ SWITCH_DECLARE(switch_status_t) switch_os_sock_get(switch_os_socket_t *thesock,
 	return apr_os_sock_get(thesock, sock);
 }
 
+SWITCH_DECLARE(switch_status_t) switch_os_sock_put(switch_socket_t **sock, switch_os_socket_t *thesock, switch_memory_pool_t *cont)
+{
+	return apr_os_sock_put(sock, thesock, cont);
+}
+
 SWITCH_DECLARE(switch_status_t) switch_socket_addr_get(switch_sockaddr_t ** sa, switch_bool_t remote, switch_socket_t *sock)
 {
 	return apr_socket_addr_get(sa, (apr_interface_e) remote, sock);
diff --git a/src/switch_ivr_play_say.c b/src/switch_ivr_play_say.c
index b632302..34f62c0 100644
--- a/src/switch_ivr_play_say.c
+++ b/src/switch_ivr_play_say.c
@@ -732,6 +732,7 @@ SWITCH_DECLARE(switch_status_t) switch_ivr_record_file(switch_core_session_t *se
 
 			if (score < fh->thresh) {
 				if (!--fh->silence_hits) {
+					switch_channel_set_variable(channel, "silence_hits_exhausted", "true");
 					break;
 				}
 			} else {
-- 
1.7.1

